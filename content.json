{"pages":[{"title":"书单","text":"书籍 开始时间 结束时间 完成度 备注 Java编程思想 2017-11-02 30% 我认为至少读三遍，每次都有收获 大话设计模式 2018-03-12 2018-08-28 100% 深入理解Java虚拟机 2018-01-04 30% Effective Java 中文版 2018-06-09 10% 强烈推荐 编写高质量代码-151个建议 2018-04-12 代码整洁之道 2018-06-20 2018-07-26 80% 读起来啰嗦，晦涩，不推荐 Java8实战 2018-07-25 2018-08-23 100% 非常好","link":"/read/index.html"},{"title":"about","text":"个人简介姓名：flyhero关注：Java地点：上海邮箱：echo -n &quot;aWZseWFwaUBnbWFpbC5jb20=&quot; | base64 -DGithub：https://github.com/flyhero 职业技能语言：熟悉Java,了解C语言前端：了解javascirpt、jsp、html、css、Jquery、bootstrap后台：熟悉Spring、SpringMVC、Mybatis，Spring boot，Spring Cloud的应用服务器：熟悉Tomcat数据库：熟悉mysql脚本: 简单Shell脚本虚拟化：Docker的使用构建：了解Maven版本控制：Git , SVN系统：熟练使用MacOS以及linux日常操作","link":"/about/index.html"},{"title":"notebook","text":"工作手册总结工作中需要注意的方方面面 态度篇 每日小会议总结是必须的（及时沟通） 完不成要提前预警，降低上级部门的预期 着手之前通观全局，决定架构和方案，不要走一步算一步。 把问题问清楚，把问题表述清楚。 把所有东西整理成文档。 有个规划，每日任务 主动承担责任（早晚有意想不到的结果） 消息或文件传输后一定要有回执。 A: 前天让你发给我的文件，怎么到现在还没发送？B：不是已经发给你了吗？（赶紧回头看记录，发现文件前有个感叹号❗️）B：不好意思，不知道是不是网络原因，那天没有发送成功。 别人指出的问题，不要反感，除非你有理由说服别人你是正确的。 请假要尽量提前一些天，让领导能提前协调大家工作的进展。 周五结束工作时，列出下周一要做的事情，这样可以减少休息到工作的过度时间。 工具 IDEA 插件下载失败System Setting -&gt; Updates -&gt; 取消 Use secure connection 技术篇日志 入参一定要打印出来，方法中每个return前要打印说明原因。 循环中谨慎打印日志 服务 暴露的服务仅提供的jar应是最简化版，仅包含暴露所需。 使用spring Transactional注解时，注意它只作用于public方法。 数据库 不要在代码循坏语句内连接数据库。这会让数据库内存很快涨起来。 修改mysql server 的最大连接数（默认150个），当你超过时会收到一个异常 Too many connections,有两个命令可以帮到你： 123456#查看进程show processlist; #查看最大连接设置show variables like 'max_connections'; #设置最大连接数set GLOBAL max_connections=1500; 这种设置，一旦server重启后就失效了，最根本的是修改配置文件。 不要在 in 中放置过多内容，会导致程序出现Caused by: com.mysql.jdbc.PacketTooBigException: Packet for query is too large (1379 &gt; 1024). You can change this value on the server by setting the max_allowed_packet&#39; variable. 不要把数组转成字符串在in中，如果这样，它只会匹配第一个逗号之前的数字（下面例子即只匹配id为1的）。反例： 1String ids = \"1,2,3\"; 1select * from a where id in ('1,2,3') 如果确实需要，你可以修改mysql server 的max_allowed_packet大小。方式如下： 123show variables like '%max_allowed_packet%';# 扩大配置限制，将1024（1M）增大，将其修改为20Mset global max_allowed_packet = 2*1024*1024*10; 大小写问题 库表列名称：windows下默认不区分大小写，linux下默认是区分大小写的。 字段内容：mysql默认的字符检索策略：utf8mb4_general_ci，表示不区分大小写; utf8mb4_bin表示二进制比较，同样也区分大小写。可通过下面来修改表及列的字符集：ALTER TABLE table_name DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci 面试篇 了解清楚公司的产品有多少？用到什么技术？有什么依赖？ 同语言开发不低于5人，各个层级是否有人（高中初级）？是否有技术积累（展示渠道，可回家看看）？ 公司的环境，吃饭和厕所是比较重要的事情，有时间可以去卫生间看看，一个卫生间基本可以看出工作环境。 最后是关于福利","link":"/notebook/index.html"}],"posts":[{"title":"MySQL主从复制搭建","text":"主从复制是为了以防万一一台机器出现问题，备用数据库能及时补充上。 节点 Host IP Software Port OS Master/Slave server-1 192.168.1.1 MySQL 5.7 3306 CentOS 6.8 Master server-2 192.168.1.2 MySQL 5.7 3306 CentOS 6.8 Slave 安装启动 删除旧版本1yum remove mysql* 下载安装配置文件 1wget https://dev.mysql.com/get/mysql57-community-release-el6-11.noarch.rpm 先安装刚下载的文件 1yum localinstall mysql57-community-release-el6-11.noarch.rpm 查看一下信息 1yum repolist all | grep mysql 默认enable的是5.7版本 1yum install mysql-community-server 启动 1service mysqld start 获取临时密码为了加强安全性，MySQL5.7为root用户随机生成了一个密码，在error log中，关于error log的位置，如果安装的是RPM包，则默认是/var/log/mysqld.log。只有启动过一次mysql才可以查看临时密码 12$ grep 'temporary password' /var/log/mysqld.loghost:*** 星号处为密码。 登录并修改密码 密码大小写数字字母特殊符号混合，否则不容易设置成功。 123mysql -uroot -p&gt; 密码mysql &gt; ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;密码&apos;; 两个节点均同样的操作 主从复制创建用于复制的账号创建一个名为slave的账号通过密码*来登录，只允许从192.168.1.2来登录。 12mysql&gt; grant replication slave on *.* to 'slave'@'192.168.1.2' identified by '密码'; mysql&gt; flush privileges; Master配置 修改/etc/my.cnf文件如下： 123456789port=3306 #[必须]启用二进制日志 binlog-ignore-db=mysql #[必须]服务器唯一ID，默认是1 server-id= 1 #只保留7天的二进制日志，以防磁盘被日志占满 expire-logs-days = 7 #不备份的数据库 binlog-ignore-db=mysql 重启 1service mysqld restart 查看主服务器上当前的二进制日志名和偏移量值 1234567mysql&gt; show master status; +------------------+----------+--------------+--------------------------+-------------------+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set | +------------------+----------+--------------+--------------------------+-------------------+ | mysql-bin.000001 | 154 | | mysql | |+------------------+----------+--------------+-------------------------+-------------------+ 1 row in set (0.00 sec) --------------------- 这里的 File 、Position 是在配置Salve的时候要使用到的。 Slave配置 修改/etc/my.cnf文件如下： 123server-id=2 #此值不能和主数据库的一样，唯一 replicate-do-db = test #可以指定要复制的库 replicate-ignore-db = mysql #忽略的库 设置Slave 123mysql&gt; stop slave; #关闭Slave mysql&gt; change master to master_host='192.168.1.1',master_user='slave',master_password='密码',master_log_file='mysql-bin.000001', master_log_pos= 154; mysql&gt; start slave; #开启Slave 注意：在这里指定Master的信息，master_log_file是在配置Master的时候的File选项， master_log_pos是在配置Master的Position 选项，这里要进行对应。 查看Slave配置1234567891011121314151617mysql&gt; show slave status \\G; *************************** 1. row *************************** Slave_IO_State: Master_Host: 192.168.1.1 Master_User: slave Master_Port: 3306 Connect_Retry: 60 Master_Log_File: mysql-bin.000001 Read_Master_Log_Pos: 154 Relay_Master_Log_File: mysql-bin.000001 Slave_IO_Running: Yes Slave_SQL_Running: Yes Skip_Counter: 0 Exec_Master_Log_Pos: 154 Relay_Log_Space: 154 1 row in set (0.00 sec) ERROR: No query specified Slave_IO_Running：连接到主库，并读取主库的日志到本地，生成本地日志文件。Slave_SQL_Running:读取本地日志文件，并执行日志里的SQL命令。如果Slave_IO_Running 与 Slave_SQL_Running 的值都必须为YES，表明成功了； 排错 Slave_SQL_Running: No一般是由于事物回滚造成的。解决： 123mysql&gt; slave stop;mysql&gt; set GLOBAL SQL_SLAVE_SKIP_COUNTER=1;mysql&gt; slave start; Slave_IO_Running: No可能是主库是的master的信息有变化导致的。解决： 查看master的状态show master status slave库执行：123mysql&gt;stop slave;mysql&gt;change master to master_log_file='例如mysql-bin.000005',master_log_pos=数字;mysql&gt;start slave;","link":"/2018/09/29/MySQL主从复制搭建/"},{"title":"Kafka集群搭建","text":"分布式系统中，提起消息队列估计大家想到的都是Kafka这家伙，因为这家伙快速持久化，高吞吐，性能好。 简介Apache kafka是由Apache软件基金会开发的一个开源流处理平台，由Scala和Java编写。Kafka是一种高吞吐量的分布式发布订阅消息系统，是消息中间件的一种，用于构建实时数据管道和流应用程序。本文不对kafka做过多的介绍，详情请Google. 节点列表 host IP Software Port OS server-1 192.168.1.1 kafka-2.11-2.0.0 9092 CentOS 6.8 server-2 192.168.1.2 kafka-2.11-2.0.0 9092 CentOS 6.8 server-3 192.168.1.3 kafka-2.11-2.0.0 9092 CentOS 6.8 安装1234567[192.168.1.1]~$ wget http://archive.apache.org/dist/kafka/2.0.0/kafka_2.11-2.0.0.tgz[192.168.1.1]~$ tar -zxvf kafka_2.11-2.0.0.tgz -C /usr/local/[192.168.1.1]~$ mv /usr/local/kafka_2.11-2.0.0 /usr/local/kafka[192.168.1.1]~$ mkdir /usr/local/kafka/logs 其它两个机器同样执行上面过程 配置 打开配置 1[192.168.1.1]~$ vim server.properties 修改 1234567891011121314#唯一值，每个server填写不一样。broker.id=1#修改；协议、当前broker机器ip、端口，此值可以配置多个，跟SSL等有关系。listeners=PLAINTEXT://192.168.1.1:9092#修改；kafka数据的存放地址，多个地址的话用逗号分割log.dirs=/usr/local/kafka/logs#每个topic的分区个数，若是在topic创建时候没有指定的话会被topic创建时的指定参数覆盖。num.partitions=3#kafka连接的zk地址，各个broker配置一致。zookeeper.connect=192.168.1.1:2181,192.168.1.2:2181,192.168.1.3:2181 新增 1234567891011121314#新增；表示消息体的最大大小，单位是字节。message.max.bytes=5242880#新增；是否允许自动创建topic，若是false，就需要通过命令创建topic。default.replication.factor=2#新增；replicas每次获取数据的最大大小。replica.fetch.max.bytes=5242880#新增；配置文件中必须使用以下配置，否则只会标记为删除，而不是真正删除。delete.topic.enable=true#新增；是否允许 leader 进行自动平衡，boolean 值，默认为 true。auto.leader.rebalance.enable=true 其它两个机器同样执行上面过程 集群状态启动12345[192.168.1.1]~$ /usr/local/kafka/bin/kafka-server-start.sh /usr/local/kafka/config/server.properties[192.168.1.2]~$ /usr/local/kafka/bin/kafka-server-start.sh /usr/local/kafka/config/server.properties[192.168.1.3]~$ /usr/local/kafka/bin/kafka-server-start.sh /usr/local/kafka/config/server.properties","link":"/2018/09/27/Kafka集群搭建/"},{"title":"Redis集群搭建","text":"Redis是使用缓存必不可少的服务，一方面是因为redis读写速度比较快，另一方面是支持的数据类型比较多。 简介Redis 是一个开源的 key-value 存储系统，由于出众的性能，大部分互联网企业都用来做服务器端缓存。Redis 在3.0版本前只支持单实例模式，虽然支持主从模式、哨兵模式部署来解决单点故障，但是现在互联网企业动辄大几百G的数据，可完全是没法满足业务的需求，所以，Redis 在 3.0 版本以后就推出了集群模式。 节点列表 Host IP Software Port OS Master/Slave server-1 192.168.1.1 Redis 3.2.2 7000 CentOS 6.8 Master server-2 192.168.1.2 Redis 3.2.2 7001 CentOS 6.8 Master server-3 192.168.1.3 Redis 3.2.2 7002 CentOS 6.8 Master server-4 192.168.1.4 Redis 3.2.2 7003 CentOS 6.8 Slave server-5 192.168.1.5 Redis 3.2.2 7004 CentOS 6.8 Slave server-6 192.168.1.6 Redis 3.2.2 7005 CentOS 6.8 Slave 安装Redis123456# wget http://download.redis.io/releases/redis-3.2.2.tar.gz# tar -zxvf redis-3.2.2.tar.gz -C /usr/local/# cd /usr/local/# mv redis-3.2.2 redis-cluster# cd redis-cluster &amp; mkdir -p 7000/data# cp /usr/local/redis-cluster/* /usr/local/redis-cluster/7000 编译解压后的redis是没有启动redis-server等命令的，所以需要make编译。 123456789#先确保安装了make命令#make是gcc的编译器#安装：yum -y install gcc automake autoconf libtool make#安装g++:yum install gcc gcc-c++cd redis-clustermake &amp;&amp; make install 其他机器同样执行上面步骤（更改端口号） 修改配置 打开配置文件 1vim /usr/local/redis-cluster/7000/conf/redis.conf 修改 123456789101112131415161718# 关闭保护模式protected-mode no# 每个节点的端口号port 7000 #redis后台运行daemonize yes # 绑定当前机器IPbind 192.168.1.1# 数据文件存放位置dir /usr/local/redis-cluster/7000/data/ # pid 7000和port要对应pidfile /var/run/redis_7000.pid# 启动集群模式cluster-enabled yes cluster-config-file /usr/local/redis-cluster/7000/conf/nodes_7000.conf cluster-node-timeout 15000 # aof日志开启，有需要就开启，它会每次写操作都记录一条日志appendonly yes 其他机器同样，只需要更改对应端口 启动单节点每一个节点都这样启动：1/usr/local/redis-cluster/7000/bin/redis-server /usr/local/redis-cluster/7000/conf/redis.conf 设置密码 新建一个文件redis-auth.conf，内容如下,替换密码： 1234config set masterauth [密码]config set requirepass [密码]auth [密码]config rewrite 设置密码 123# cat redis-auth.conf | /usr/local/redis-cluster/7000/bin/redis-cli -c -p 7000# cat redis-auth.conf | /usr/local/redis-cluster/7000/bin/redis-cli -c -p 7001# 以此类推其他机器 构建集群安装Ruby构建集群的 redis-trib.rb 命令是用Ruby写的,所以需要安装Ruby运行环境。 1234$ yum -y install ruby ruby-devel rubygems rpm-build$ gem install redis$ ruby -vruby 2.3.1p112 (2016-04-26) [x86_64-linux-gnu] 启动集群123456redis-trib.rb create --replicas 1 192.168.1.1:7000 192.168.1.2:7001 192.168.1.3:7002 192.168.1.4:7003 192.168.1.5:7004 192.168.1.6:7005 命令中--replicas 1表示主从复制比例为 1:1，即一个主节点对应一个从节点；然后，默认给我们分配好了每个主节点和对应从节点服务。 验证集群123456$ /usr/local/redis-cluster/7000/bin/redis-cli -c -h 192.168.1.1 -p 7000192.168.1.1:7000 &gt; auth 密码# 查找一个不存在的key192.168.1.1:7000 &gt; get abc192.168.1.4:7003 &gt; 当获取本节点不存在的key时，redis会跳转到其他节点。 集群信息 12192.168.1.1:7000&gt; cluster nodes192.168.1.1:7000&gt; cluster info 排错 编译redis时，make出错解决： make MALLOC=libc redis-trib.rb 构建redis集群的时候问题：redis requires Ruby version &gt;= 2.2.2解决：此时需要安装更高的Ruby，方法如下： 12345678910# 会在/etc/yum.repos.d/目录下多出一个CentOS-SCLo-scl-rh.repo源$ yum install centos-release-scl-rh # 直接yum安装即可 $ yum install rh-ruby23 -y $ scl enable rh-ruby23 bash# 查看安装版本$ ruby -v $ gem install redis","link":"/2018/09/29/Redis集群搭建/"},{"title":"Java位运算","text":"我们日常开发中为运算使用的并不多，但如果能巧妙的使用位运算可以减少运行开销和优化算法，通过Java的源码可知，如HashMap。 单位换算 bit：位 一个二进制数据0或1，是1bit； byte：字节1 byte = 8 bit , 存储空间的基本计量单位 一个英文字符占一个字节；1 字母 = 1 byte = 8 bit 一个汉字占2个字节；1 汉字 = 2 byte = 16 bit 支持的数据类型首先明确一点，Java中的位运算是针对整型的数据类型进行运算的，所以操作数必须是一下五种之一。 数据类型 所占位数（bit） byte 8 short 16 int 32 long 64 char 16 数据存储方式计算机中存储的数据最终是以二进制存储，如int类型的十进制数字10表示为32bit的二进制： 0000 0000 0000 0000 0000 0000 0000 1010 位运算符 运算符 意义 &amp; 按位与 &#124; 按位或 ~ 按位非 ^ 按位异或 &lt;&lt; 左移 &gt;&gt; 右移 &lt;&lt;&lt; 无符号右移 按位与&amp; 操作 十进制 二进制 操作数1 3 0 0 1 1 操作数2 5 0 1 0 1 &amp; 后结果 1 0 0 0 1 总结：对应位同为1时，才为1，否则全为0（对应位只要有0，全为0，否则为1）。 另外：你可以把1理解为true,把0理解为false, true和false进行与（&amp;）时，必须同为true时结果才为true. 按位或 | 操作 十进制 二进制 操作数1 3 0 0 1 1 操作数2 5 0 1 0 1 &#124; 后结果 7 0 1 1 1 总结：对应位只要有1时，即为1，否则全为0（对应位只有全是0时，结果才是0，否则为1）。 另外：你可以把1理解为true,把0理解为false, true和false进行或（|）时，只要有true,结果即为true. 按位非~ 操作 十进制 二进制 操作数1 3 0 0 1 1 ~ 后结果 12 1 1 0 0 总结：对每位进行取反。 按位异或 ^ 操作 十进制 二进制 操作数1 3 0 0 1 1 操作数2 5 0 1 0 1 ^ 后结果 7 0 1 1 0 总结：只要对应为不同即为1 左移&lt;&lt; 和 右移 &gt;&gt;通过下面的图更加直观： 左移总结 m&lt;&lt;n即在数字没有溢出的前提下，对于正数和负数，左移n位都相当于m乘以2的n次方。 溢出情况举例：5&lt;&lt;29，相当于 （2^2 + 1） * 2^29 ，这个结果显然大于正数的最大值 2^31-1，所以得出的是个负数。 右移总结 m&gt;&gt;n即相当于m除以2的n次方，得到的为整数时，即为结果。如果结果为小数，此时会出现两种情况： 如果m为正数，得到的商会无条件 的舍弃小数位； 如果m为负数，舍弃小数部分，然后把整数部分加+1得到位移后的值。 无符号右移 &gt;&gt;&gt;无符号右移&gt;&gt;&gt; 与 右移&gt;&gt; 的区别就是无论操作数是正数还是负数，高位都是补0。","link":"/2018/07/16/Java位运算/"},{"title":"Shell简介","text":"Shell可理解为一种命令语言解释器，他拥有自己内建的shell命令集，他负责接收用户输入的命令送去linux 内核执行。 什么是Shell?通俗的说：我们必须通过Shell将我们输入的命令与Kernel沟通，让Kernel可以控制硬件来正确工作。 Shell脚本 Shell 脚本（shell script），是一种为 shell 编写的脚本程序。 shell脚本文件扩展名一般.sh结尾，sh即代表shell，这样做更加见名知意。 Shell的种类 /bin/sh (已经被 /bin/bash 所取代) /bin/bash (就是 Linux 默认的 shell) /bin/ksh (Kornshell 由 AT&amp;T Bell lab. 发展出来的，兼容于 bash) /bin/csh (已经被 /bin/tcsh 所取代) /bin/tcsh (整合 C Shell ，提供更多的功能) /bin/zsh (基于 ksh 发展出来的，功能更强大的 shell) 通过执行下面命令查看到当前系统默认的shell12echo $SHELL/bin/bash Shell脚本组成：第一行：表示以那种shell方式来运行 1#!/bin/bash #! 是一种约定的标记 /bin/bash 表示shell的完全路径 执行方式 作为可执行程序 直接执行shell脚本文件12chmod +x ./start.sh # 使文件具有执行权限./start.sh # 运行脚本 1.使用相对路径，如上./ 表示在当前路径下寻找文件 2.使用绝对路径，例如：/home/start.sh 作为解释器参数 直接运行解释器，把脚本文件作为参数 1/bin/bash start.sh 这种方式下，脚本文件中不需要在第一行指定哪种shell. 样例12345#!/bin/bash# 单独使用代表注释# echo 控制台输出echo \"hello world !\"","link":"/2018/04/29/Shell简介/"},{"title":"SQL查询今天、明天、本周、本月","text":"统计sql 123456789101112131415161718192021222324252627282930-- 今天SELECT *FROM d2_lecture where to_days(FROM_UNIXTIME(start_time))= to_days(now())-- 明天SELECT *FROM d2_lecture where to_days(FROM_UNIXTIME(start_time))= to_days(now())+1-- 7天内SELECT * FROM d2_lecture where DATE(FROM_UNIXTIME(start_time))&gt;DATE_SUB(CURDATE(), INTERVAL 7 DAY)-- 本周内SELECT * FROM d2_lecture WHERE YEARWEEK(date_format(FROM_UNIXTIME(start_time),'%Y-%m-%d')) = YEARWEEK(now());-- 本周末SELECT * FROM d2_lecture WHERE YEARWEEK(date_format(FROM_UNIXTIME(start_time),'%Y-%m-%d')) = YEARWEEK(now()) AND DAYOFWEEK(date_format(FROM_UNIXTIME(start_time),'%Y-%m-%d')) in(1,7) -- 本月select *from d2_lecture where date_format(FROM_UNIXTIME(start_time),'%Y-%m')=date_format(now(),'%Y-%m')","link":"/2016/09/19/SQL查询今天、明天、本周、本月/"},{"title":"Solr的搭建与使用（一）","text":"由于参与的项目与政府部门有关，数据量非常大，仅仅依靠数据库sql语句来检索数据是很耗时的一件事，所以我们选择了使用solr来做全文检索。 简介Solr是一个高性能，采用Java5开发，基于Lucene的全文搜索服务器。同时对其进行了扩展，提供了比Lucene更为丰富的查询语言，同时实现了可配置、可扩展并对查询性能进行了优化，并且提供了一个完善的功能管理界面，是一款非常优秀的全文搜索引擎。 搭建搭建前提windows或linux；JDK1.5以上；Tomcat(可选)； Windows下搭建下载zip包官网地址：http://lucene.apache.org/solr/各版本汇总：http://archive.apache.org/dist/lucene/solr/ 方式一 solr自带jetty服务器解压zip包到任意位置，cmd进入到.\\solr-5.2.1\\bin目录下，执行命令：solr start然后你会在dos界面看到：12Starting Solr on port 8983 from D:\\solr-5.2.1\\serverDirect your Web browser to http://localhost:8983/solr to visit the Solr Admin UI 然后打开浏览器输入：http://localhost:8983/solr solr脚本命令：1234前台运行 bin/solr start -f指定端口号 bin/solr start -p 9000（默认端口号8983）查看solr状态 bin/solr status结束solr bin/solr stop -p 9000 方式二 在Tomcat下step1:将.\\solr\\server\\webapp下的solr.war复制到tomcat下的webapps里然后启动tomcat将自动解压war包，解压后将war包删除。 step2:修改.\\apache-tomcat-7.0.67\\webapps\\solr\\WEB-INF下的web.xml在文件中取消如下的注释：12345&lt;env-entry&gt; &lt;env-entry-name&gt;solr/home&lt;/env-entry-name&gt; &lt;env-entry-value&gt;/put/your/solr/home/here&lt;/env-entry-value&gt; &lt;env-entry-type&gt;java.lang.String&lt;/env-entry-type&gt;&lt;/env-entry&gt; 其中/put/your/solr/home/here修改为.\\solr-5.2.1\\server\\solr这个路径。 step3: 将\\solr-5.2.1\\server\\lib\\ext下的所有jar包复制到\\apache-tomcat-7.0.67\\webapps\\solr\\WEB-INF\\lib下； 将\\solr-5.2.1\\server\\resources下的log4j.properties复制到\\apache-tomcat-7.0.67\\webapps\\solr\\WEB-INF\\classes下。（若无classes新建即可）； 重启tomcat后，打开浏览器输入：http://localhost:8080/solr 看到界面即为成功部署。 创建core 关闭tomat，将\\solr-5.2.1\\dist\\下的solr-dataimporthandler-5.2.1.jar和solr-dataimporthandler-extras-5.2.1.jar复制到\\apache-tomcat-7.0.67\\webapps\\solr\\WEB-INF\\lib目录下（这两个包主要把数据从关系型数据库导入到solr服务器用到）； 进入\\solr-5.2.1\\server\\solr目录下，创建名为test的文件夹； 将\\solr-5.2.1\\example\\example-DIH\\solr\\solr下的conf文件夹复制到test文件夹下； 在test文件夹下创建名为data的文件夹； 启动tomcat，进入solr界面，点击Add Core创建如下图： 学习资源以下资源来自：http://www.aboutyun.com/thread-10830-1-1.html solr应用之电商搜索链接：http://pan.baidu.com/s/1vXBbg 密码：57r8 solr常用、基本功能的在电商中的应用链接：http://pan.baidu.com/s/1i303cO1 密码：kulc DIH关系型数据库创建索引链接：http://pan.baidu.com/s/1ntl1OE1 密码：fsn0 Solr应用之日志索引系统链接：http://pan.baidu.com/s/1kT3gNWj 密码：fp4a 企业搜索介绍入门篇(第二集IK分词配置forSolr4.3)下链接：http://pan.baidu.com/s/1qW9IoZ6 密码：c3gt 企业搜索介绍链接：http://pan.baidu.com/s/1ntKDIjB 密码：c1x2 lucene打分_clip链接：http://pan.baidu.com/s/1o63GExG 密码：lfgw 应用答疑（上）_知识讲解链接：http://pan.baidu.com/s/1bnCkAwZ 密码：9hkt 应用答疑（下）_案例分析链接：http://pan.baidu.com/s/1dDEiy9F 密码：4kcs 使用solrJ进行索引的创建和查询_clip链接：http://pan.baidu.com/s/1jG66DM2 密码：wbo1","link":"/2016/06/07/Solr的搭建与使用（一）/"},{"title":"Solr的搭建与使用（二）","text":"添加中文分词器首先我们来测试一下solr对中英文的分词效果：由于solr对中文分词不太友好，需要添加中文分词器。 下载分词器，地址：http://download.csdn.net/detail/u010995578/9402443； 把jar包复制到\\apache-tomcat-7.0.67\\webapps\\solr\\WEB-INF\\lib路径下； 修改\\solr-5.2.1\\server\\solr\\test\\conf下的schema.xml文件，添加如下： 12345&lt;!--添加IK中文分词器--&gt;&lt;fieldType name=&quot;text_ik&quot; class=&quot;solr.TextField&quot;&gt; &lt;analyzer type=&quot;index&quot; useSmart=&quot;false&quot; class=&quot;org.wltea.analyzer.lucene.IKAnalyzer&quot;/&gt; &lt;analyzer type=&quot;query&quot; useSmart=&quot;true&quot; class=&quot;org.wltea.analyzer.lucene.IKAnalyzer&quot;/&gt; &lt;/fieldType&gt; 打开solr页面，找到test_ik字段名，测试一下效果： 添加自定义词库：解压刚才下载的jar包，如图： 把ext.dic和IKAnalyzer.cfg.xml复制到\\apache-tomcat-7.0.67\\webapps\\solr\\WEB-INF\\classes下； 用notepad++打开ext.dic可编辑自定义的词。本节参考 ：http://www.superwu.cn/2015/05/08/2134/http://iamyida.iteye.com/blog/2220474?utm_source=tuicool&amp;utm_medium=referral导入数据 区分你要从什么数据库导入，从什么数据库导入就下载什么数据库相应的驱动jar包； 关闭tomat，将你的jar包复制到\\apache-tomcat-7.0.67\\webapps\\solr\\WEB-INF\\lib下； 将\\solr-5.2.1\\dist\\下的solr-dataimporthandler-5.2.1.jar和solr-dataimporthandler-extras-5.2.1.jar复制到\\apache-tomcat-7.0.67\\webapps\\solr\\WEB-INF\\lib目录下； 打开\\solr-5.2.1\\server\\solr\\test\\conf下的solrconfig.xml文件看看是否存在以下：12345&lt;requestHandler name=&quot;/dataimport&quot; class=&quot;solr.DataImportHandler&quot;&gt; &lt;lst name=&quot;defaults&quot;&gt; &lt;str name=&quot;config&quot;&gt;solr-data-config.xml&lt;/str&gt; &lt;/lst&gt;&lt;/requestHandler&gt; 如不存在，添加进去； 打开同路径下的data-config.xml，添加如下：12345678910111213&lt;dataConfig&gt; &lt;dataSource type=&quot;JdbcDataSource&quot; driver=&quot;oracle.jdbc.driver.OracleDriver&quot; url=&quot;jdbc:oracle:thin:@//127.0.0.1:1521/orcl&quot; user=&quot;root&quot; password=&quot;123456&quot; batchSize=&quot;10000&quot;/&gt; &lt;document name=&quot;search&quot;&gt; &lt;entity name=&quot;view_table&quot; pk=&quot;id&quot; query=&quot;select * from s_table&quot;&gt; &lt;field column=&quot;id&quot; name=&quot;id&quot;/&gt; &lt;field column=&quot;title&quot; name=&quot;title&quot;/&gt; &lt;field column=&quot;content&quot; name=&quot;content&quot;/&gt; &lt;/entity&gt; &lt;/document&gt; 配置好自己的数据源即可，多个表的话就追加entity标签即可。 需要将你上述表中的字段添加到同目录下的schema.xml中，如：&lt;field name=&quot;title&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt; 最后点击Dataimport,可以看到Command有full-import和delta-import两种），第一次可以选full-import，Entity下拉框面选view_table，选中“Auto-Refresh Status”，点击Execute,可以看到右边状态：Indexing，最后变为Indexing completed表示索引已经建好了。然后点击左侧的Query，在q下面的输入框中输入：password:aaa，点击Execute Query来从索引中查询password为aaa的结果。Java代码导入数据数据库中存在一个字段用来标识本条记录是否已经导入，这个字段有三种状态：0未导入，1正在导入，2已导入。一般这种导入我们是为了定时导入新生成的数据，作为后台job任务。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293import java.net.URI;import java.net.URL;import java.sql.Connection;import java.sql.SQLException;import java.sql.Statement;import org.apache.log4j.Logger;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.JdbcTemplate;import com.sun.jersey.api.client.Client;import com.sun.jersey.api.client.WebResource;public class SolrDataImport &#123; Logger logger = Logger.getLogger(SolrDataImport.class); @Autowired protected JdbcTemplate jdbcTemplate; //多个表 private String[] tableNames = &#123; &quot;表1&quot;,&quot;表2&quot;,&quot;表3&quot; &#125;; public void run()&#123; logger.info(&quot;-------Solr入库JOB 执行开始------------------&quot;); String solrPath = &quot;http://localhost:8080/solr/mytest/dataimport?command=full-import&amp;clean=false&amp;commit=true&quot;; String solrStatusPath = &quot;http://localhost:8080/solr/mytest/dataimport?command=status&quot;; logger.info(&quot;获取dataimport地址&quot;+solrPath); updateLog(&quot;0&quot;, &quot;1&quot;); get(solrPath); String result = get(solrStatusPath); try &#123; while(true)&#123; if(result.indexOf(&quot;busy&quot;) !=-1)&#123; Thread.sleep(1000); result = get(solrStatusPath); &#125;else if(result.indexOf(&quot;idle&quot;) !=-1)&#123; break; &#125;else&#123; updateLog(&quot;1&quot;,&quot;0&quot;); return; &#125; &#125; &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; updateLog(&quot;1&quot;, &quot;2&quot;); logger.info(&quot;-------Solr入库JOB 执行结束------------------&quot;); &#125; private String get(String url_)&#123; Client c = Client.create(); //创建一个Client的实例 String result = &quot;&quot;; try &#123; //配置Client参数 URL url = new URL(url_); URI uri = new URI(url.getProtocol(), url.getHost()+&quot;:&quot;+url.getPort(), url.getPath(), url.getQuery(), null); //获取一个WebResource实例 WebResource resource = c.resource(uri); //发送了一个Get请求 result = resource.get(String.class); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; return result; &#125; //更新数据库表记录的状态 private void updateLog(String from,String state)&#123; String sql = &quot;&quot;; Connection connection = null; Statement st = null; try &#123; connection = jdbcTemplate.getDataSource().getConnection(); connection.setAutoCommit(false); st = connection.createStatement(); for(String table :tableNames)&#123; sql = &quot;update &quot;+ table+&quot; t set LAST_MODIFIED=&apos;&quot;+state+ &quot;&apos; where LAST_MODIFIED=&apos;&quot;+from+&quot;&apos;&quot;; st.executeUpdate(sql); connection.commit(); logger.info(&quot;更新表状态sql:&quot;+sql); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally&#123; try &#123; st.close(); connection.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;","link":"/2016/06/08/Solr的搭建与使用（二）/"},{"title":"Spring整合Quartz任务调度","text":"阅读本文你将了解到： 什么是Quartz？ Quartz的特点？ 任务调度的实现方式 Cron表达式 什么是Quartz？Quartz是OpenSymphony开源组织在Job scheduling领域又一个开源项目，它可以与J2EE与J2SE应用程序相结合也可以单独使用。Quartz可以用来创建简单或为运行十个，百个，甚至是好几万个Jobs这样复杂的程序。Jobs可以做成标准的Java组件或 EJBs 下面是本文中用到的一些专用词汇，在此声明：scheduler：任务调度器trigger：触发器，用于定义任务调度时间规则job：任务，即被调度的任务misfire：错过的，指本来应该被执行但实际没有被执行的任务调度 Quartz的特点？作为一个优秀的开源调度框架，Quartz 具有以下特点： 强大的调度功能，例如支持丰富多样的调度方法，可以满足各种常规及特殊需求； 灵活的应用方式，例如支持任务和调度的多种组合方式，支持调度数据的多种存储方式； 分布式和集群能力，Terracotta 收购后在原来功能基础上作了进一步提升。 作为 Spring 默认的调度框架，Quartz 很容易与 Spring 集成实现灵活可配置的调度功能。 任务调度的实现方式 创建Maven project; 添加Spring和Quartz的Jar包，如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 &lt;!-- quartz start--&gt; &lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- quartz end --&gt; &lt;!--spring start --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--spring end --&gt; 纯注解方式 创建job任务12345678910111213141516package com.flyhero.demo;import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Component;@Componentpublic class QuartzJob &#123; private int i=0; //9点到17点间每隔一分钟执行一次 @Scheduled(cron = &quot;0 0/1 9-17 * * ? &quot;) public void taskQuartz()&#123; i++; System.out.println(&quot;now i=&quot;+i); &#125;&#125; XML配置方式 新建普通job类 12345678package com.flyhero.demo;public class QuartzNewJob &#123; public void run()&#123; System.out.println(&quot;xml配置定时任务执行！&quot;); &#125;&#125; 在spring-quartz.xml配置文件中配置如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:task=&quot;http://www.springframework.org/schema/task&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task.xsd &quot;&gt;&lt;!-- &lt;task:annotation-driven /&gt; &lt;context:annotation-config /&gt; &lt;context:component-scan base-package=&quot;com.flyhero.demo&quot;/&gt; --&gt; &lt;bean id=&quot;job&quot; class=&quot;com.flyhero.demo.QuartzNewJob&quot; &gt;&lt;/bean&gt; &lt;!-- MethodInvokingJobDetailFactoryBean用来将一个Spring bean包装为一个job --&gt; &lt;!-- 使用MethodInvokingJobDetailFactoryBean包装的job不能被序列化 --&gt; &lt;bean id=&quot;myJobDetail&quot; class=&quot;org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean&quot;&gt; &lt;!-- 被包装的Spring bean --&gt; &lt;property name=&quot;targetObject&quot; ref=&quot;job&quot; /&gt; &lt;!-- job执行方法 --&gt; &lt;property name=&quot;targetMethod&quot; value=&quot;run&quot; /&gt; &lt;!-- 无状态job --&gt; &lt;property name=&quot;concurrent&quot; value=&quot;false&quot; /&gt; &lt;/bean&gt; &lt;!-- 计划触发器 两种触发器取其一 --&gt; &lt;bean id=&quot;myCronTrigger&quot; class=&quot;org.springframework.scheduling.quartz.CronTriggerFactoryBean&quot;&gt; &lt;property name=&quot;jobDetail&quot; ref=&quot;myJobDetail&quot; /&gt; &lt;property name=&quot;cronExpression&quot;&gt; &lt;value&gt;0 0/1 * * * ?&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 简单触发器 1s后每2s执行一次 --&gt; &lt;bean class=&quot;org.springframework.scheduling.quartz.SimpleTriggerFactoryBean&quot; id=&quot;simpleTrigger&quot;&gt; &lt;property name=&quot;jobDetail&quot; ref=&quot;myJobDetail&quot;&gt; &lt;property name=&quot;startDelay&quot; value=&quot;1000&quot;&gt; &lt;property name=&quot;repeatInterval&quot; value=&quot;2000&quot;&gt; &lt;/bean&gt; &lt;bean class=&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot;&gt; &lt;property name=&quot;triggers&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;myCronTrigger&quot; /&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; 最后： 运行主程序，加载配置文件1234567891011121314package com.flyhero.test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class TestQuartz &#123; private static ApplicationContext context; public static void main(String[] args) &#123; //加载配置文件 context = new ClassPathXmlApplicationContext(&quot;spring-quartz.xml&quot;); &#125;&#125; cron表达式举例说明： 示例简单demo代码：https://github.com/flyhero/spring-quartz","link":"/2016/08/04/Spring整合Quartz任务调度/"},{"title":"git上传代码的两种方式","text":"第一种：先有远程代码，同步到本地仓库第一步：克隆远程代码cd到你的本地项目根目录下，执行git命令git clone [远程代码地址]如下：git clone https://github.com/flyhero/flyapi2.2.git 第二步：修改代码后，将项目的所有文件添加到仓库中git add . 注意后面的 . 号 第三步：将添加或修改的文件，提交到仓库git commit - m &quot;注释&quot; 第四步，上传代码到远程仓库git push -u origin master之后会提示让输入用户名和密码 第二种：先有本地代码，上传到远程仓库第一步：建立git仓库cd到你的本地项目根目录下，执行初始化命令git init第二步：将项目的所有文件添加到仓库中git add .如果想添加某个特定的文件，只需把.换成特定的文件名即可 第三步：将add的文件commit到仓库git commit -m &quot;注释语句&quot; 第四步：去github上创建自己的Repository 第五步：复制github上的仓库地址 第六步：将本地的仓库关联到远程仓库git remote add origin https://github.com/flyhero/flyapi2.2.git 第七步：上传远程仓库之前，要先pull（更新/拉下）到本地，执行如下命令：git pull origin master 第八步，上传代码到github远程仓库git push -u origin master 第九步：输入用户名和密码后，等待上传成功 注意：如果多人合作，一定要先pull代码。","link":"/2016/06/20/git上传代码的两种方式/"},{"title":"zookeeper集群搭建","text":"中小公司或许没有专门的Linux运维工程师，掌握基础的Linux操作对我们来说成为必须的要求。zookeeper是dubbo,kafka等常依赖的环境，所以安装一个zookeeper集群是必不可少的。 简介Zookeeper是一个分布式协调服务；就是为用户的分布式应用程序提供协调服务。其中集群中有几种角色：本文不对zookeeper做过多的介绍，详情请Google. zk service节点列表 host IP Software Port OS server-1 192.168.1.1 zookeeper 3.4.8 2181 CentOS 6.8 server-2 192.168.1.2 zookeeper 3.4.8 2181 CentOS 6.8 server-3 192.168.1.3 zookeeper 3.4.8 2181 CentOS 6.8 安装123456789[192.168.1.1]~$ wget http://archive.apache.org/dist/zookeeper/zookeeper-3.4.8/zookeeper-3.4.8.tar.gz[192.168.1.1]~$ tar -zxvf zookeeper-3.3.1.tar.gz -C /usr/local/[192.168.1.1]~$ mv /usr/local/zookeeper-3.3.1 /usr/local/zookeeper[192.168.1.1]~$ cd /usr/local/zookeeper/conf [192.168.1.1]~$ cp zoo_sample.cfg zoo.cfg[192.168.1.1]~$ cd .. &amp;&amp; mkdir data &amp;&amp; mkdir log 其它两个机器同样执行上面过程 配置文件修改 打开配置文件 1vim /usr/local/zookeeper/conf/zoo.cfg 修改以下内容： 12dataDir=/usr/local/zookeeper/datadataLogDir=/usr/local/zookeeper/log 在文件最后增加节点信息： 12345server.1=192.168.1.1:2888:3888server.2=192.168.1.2:2888:3888server.3=192.168.1.3:2888:3888 其它两个机器同样执行上面过程 建立配置路径myid中的内容为上面配置文件中的server.n的n数字。 123[192.168.1.1]$ echo 1 &gt; /usr/local/zookeeper/data/myid[192.168.1.2]$ echo 2 &gt; /usr/local/zookeeper/data/myid[192.168.1.3]$ echo 3 &gt; /usr/local/zookeeper/data/myid zk状态 启动 123456[192.168.1.1]$ /usr/local/zookeeper/bin/zkServer.sh start[192.168.1.2]$ /usr/local/zookeeper/bin/zkServer.sh start[192.168.1.3]$ /usr/local/zookeeper/bin/zkServer.sh start# 查看详细信息可使用/usr/local/zookeeper/bin/zkServer.sh start-foreground 查看状态 12# 查看是leader还是follower/usr/local/zookeeper/bin/zkServer.sh status 查看输出 12# 客户端命令查看输出信息[192.168.1.1]$ /usr/local/zookeeper/bin/zkCli.sh -server 192.168.1.1:2181 排错如果遇到错误：Error contacting service. It is probably not running.请检查防火墙是否阻挡了连接。","link":"/2018/09/27/zookeeper集群搭建/"},{"title":"一举拿下final","text":"final通常指被修饰的东西不能被改变的，不能被改变的原因旺往往处于设计和效率的考虑。 final常量final修饰的常量必须在被使用前进行初始化，初始化的方式无非两种：定义时赋值或构造函数内赋值 基本数据类型12345678910111213public class Test &#123; private final int A; private final int B = 3; private final int C = new Random().nextInt(); public Test() &#123; this.a = 5; &#125; public Test(int a) &#123; this.a = a; &#125;&#125; 为什么常量B要用final修饰？ 因为这种确定值(定义便立即赋值)的final常量，编译器会在编译时将该常量值带入到任何可能用到它的计算式中，这会减轻运行时的一些负担。 final修饰的常量值是在编译期间被确定的吗？ 注意上面的变量C，我们并不能以为final修饰的就能在编译时知道它的值，C的值只有在运行时被初始化时才会显现。 引用类型引用类型不能改变指的是引用被初始化指向一个对象后，就再也无法改为指向其他对象，但其指向的对象本身是可以被修改的。 1234567891011121314151617181920212223242526public class B &#123; private final D d =new D(); public D change()&#123; this.d.setS(\"change\"); return d; &#125; public D newD()&#123; this.d = new D(); return d; &#125; class D &#123; private String s= \"init\"; public String getS() &#123; return s; &#125; public void setS(String s) &#123; this.s = s; &#125; &#125;&#125; 上面代码是无法编译的，因为this.d=new D()会提示Cannot assign a value to final variable ‘d’,但是你却可以调用change()方法来改变d对象的s变量值。 final方法 为什么使用final修饰方法 设计：把方法锁定，防止继承类重写或重载。 效率：早期编译器会将final方法所有的调用转为内嵌调用，随着JVM的提高，这种方式已被丢弃。 final和private 当一个方法被private修饰，这会隐式的指定为final，这也会使得子类无法覆盖此方法，可以对private方法增加final修饰，但对该方法并不能增加任何意义。 final类String类是final应用的典型例子，可去查看《一举拿下String》。 为什么要把类指定为final？ 出于安全考虑或其他原因，你不希望该类有任何变动或被继承。 一旦类被final修饰，即代表final类中的所有成员变量和方法都会隐式的final. final参数在方法的参数列表中将参数指定为final，即代表该参数引用所指向的对象是无法改变的；若为基本类型，则表示值可以读取，但无法修改。修饰情况和final常量类似。 final相关static 和 final static强调的是该数据只存在一份 final强调该数据不可变 123456789101112public class C &#123; private final double a = Math.random(); private static double b = Math.random(); public static void main(String[] args) &#123; new C(); new C(); new C(); &#125;&#125; 上面代码运行后，a会存在3个，但b只有一个。 final，finally和finalize finally 是在异常处理时配合try-catch执行清理操作，需要清理的资源包括：打开的文件或网络连接等，它会把内存之外的资源恢复到他们的初始状态。无论try中是否有异常出现，finally里的操作都会被执行。 finalize 这是Object基类的一个方法，垃圾收集器在将对象清除出内存之前调用的清理资源方法，且此方法只会被系统调用一次，其实finalize能做的工作，try-finally能做的更好，《深入理解Java虚拟机》中建议大家忘掉这个方法的存在。","link":"/2018/02/08/一举拿下final/"},{"title":"Shell变量","text":"任何编程语言中都会存在变量，包括如何声明，命名及使用销毁变量，变量根据作用范围也被分为局部变量及全部变量。 如何定义变量命名规则 只能使用英文字母，数字和下划线，且不能以数字开头 不能存在空格 不能是bash中的关键字 大小写区分 长度不限制 定义1name=\"flyhero\" 定义变量直接使用变量名，用”=”号直接赋值,无需指定变量类型，且注意：变量名和”=”之间不能有空格。 语句赋值 上面的例子是直接赋值的方式，还有语句赋值的方式，如：12com=$(ls -l)echo $com 单引号，双引号和无引号的区别 单引号：会将单引号的内容原封不动的输出，即使有变量也不会输出。 双引号：如果呢绒中有命令或变量等，将会把这些解析出来，然后输出。 无引号：和双引号相同，但值中不能包含空格，否则会出错； 如何使用变量使用变量时只需要在变量前加入”$”符号：123my_name=\"flyhero\"echo $my_nameecho $&#123;my_name&#125; 使用变量加和不加{}的区别：加{}只是为了帮助解释器识别变量的边界。如： echo $my_nameloveyou输出为空，他会把$后整个当做一个变量，但并不存在这个变量。 变量的只读，查看和删除 只读 通过readonly命令修饰变量，可以使变量的值不能被改变。12readonly name=\"hi flyhero\"name=\"change this val\" 执行后会出错：This variable is read only. 查看变量 使用set可以查看所有变量，我们可以根据需要来查看。1set | grep name 删除 使用unset命令可以删除变量。(不能删除只读变量)1unset name 变量的种类 局部变量 在脚本或命令中定义，仅在当前的shell实例中有效，其他shell程序是无法访问的。 环境变量 所有的程序都能访问的的变量，因为有些程序需要环境变量来保证其正常的运行。shell脚本中也能定义环境变量。 位置变量 位置变量也叫位置参数，主要作用是把命令和命令的参数传递到当前执行的脚本中。1./start.sh param1 param2 位置变量用$n来获取，n表示1-9的自然数，大于9的话，要${n}来取。其中param1是$1,param2是$2 特殊变量 这些变量在以开始执行脚本时就被设置了，且无法修改。 变量 含义 $0 当前脚本的文件名 $n 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。 $# 传递给脚本或函数的参数个数。 $* 传递给脚本或函数的所有参数。 $@ 传递给脚本或函数的所有参数。被双引号(“ “)包含时，与 $* 稍有不同，下面将会讲到。 $? 上个命令的退出状态，或函数的返回值。 $$ 当前Shell进程ID，对于 Shell 脚本，就是这些脚本所在的进程ID。 $! 上一个后台指令的pid 样例1234567#!/bash/bin echo \"上个脚本/命令的返回值：\"$? echo \"脚本的名称是：\"$0 echo \"参数列表：\"$@ echo \"参数的个数：\"$# echo \"当前shell的pid:\"$$ echo \"上个后台命令的pid:\"$! 执行命令： 12345678./teshu.sh num1 num2上个脚本/命令的返回值：0脚本的名称是：./teshu.sh参数列表：num1 num2参数的个数：2当前shell的pid:49900上个后台命令的pid:","link":"/2018/05/06/Shell变量/"},{"title":"POI高效导出百万级Excel数据","text":"在一个具有统计功能的系统中，导出excel功能几乎是一定的，如何导出excel？导出的数据有多少？如何高效的导出？ Excel简介什么是excel就不用介绍了，这里主要说明不同版本下每个sheet下的行列限制。 版本区间 行数 列数 生成文件后缀 Excel 2003及以下 65535 256 xls Excel 2007及以上 1048576 16384 xlsx 由上面可知 Excel 2003及以下是无法实现单sheet百万级的数据。 Apache POI简介Apache POI 是用Java编写的免费开源的跨平台的 Java API，Apache POI提供API给Java程式对Microsoft Office（Excel、WORD、PowerPoint、Visio等）格式档案读和写的功能。POI为“Poor Obfuscation Implementation”的首字母缩写，意为“可怜的模糊实现”。 常用类 HSSF － 提供读写Microsoft Excel XLS格式档案的功能。 XSSF － 提供读写Microsoft Excel OOXML XLSX格式档案的功能。 SXSSF － 一种基于XSSF的低内存占用的API（3.8版本开始出现）。 HWPF － 提供读写Microsoft Word DOC97格式档案的功能。 XWPF － 提供读写Microsoft Word DOC2003格式档案的功能。 HSLF － 提供读写Microsoft PowerPoint格式档案的功能。 HDGF － 提供读Microsoft Visio格式档案的功能。 HPBF － 提供读Microsoft Publisher格式档案的功能。 HSMF － 提供读Microsoft Outlook格式档案的功能。 我们这里是导出Excel，所以使用的是前三个。 导出策略方案 使用XSSF和SXSSF分别导入1w,10w,100w数据 使用SXSSF，SXSSF以10w分页，SXSSF多线程以10w分页导入100w数据 性能对比 时间不包含网络耗时 类型 1w条/时间 10w条/时间 100w条/时间 XSSF 1331ms 10496ms 小心电脑💥 SXSSF 1568ms 600ms 5824ms 类型 100w条/时间 200w/时间 SXSSF 5824ms 超过最大行数 SXSSF Page 6040ms 12473ms SXSSF Page Thread 3410ms 6217ms 总结方案一 数据在万条时XSSF和SXSSF相差不大 数据上十万后SXSSF性能开始突出 数据到达百万时，XSSF已不适合使用 方案二 不进行分表时，SXSSF最多可存储1048576行 百万级数据分表存储时，使用多线程导出几乎是不使用多线程导出的一半时间 最终我得出一个导出百万级数据的最高效方案：多线程分表导出 实战 controller层 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273@RestController @RequestMapping(\"export\")public class ReportController &#123; public static final String[] TITLE = new String[]&#123;\"第1列\", \"第2列\", \"第3列\", \"第4列\", \"第5列\"&#125;; public static final String SHEET_NAME = \"page1\"; @RequestMapping(value = \"/sxssf/page/thread\") @ResponseBody public void exportSXSSFWorkbookByPageThread(HttpServletResponse response, Integer num) throws Exception &#123; //excel文件名 String fileName = System.currentTimeMillis() + \".xlsx\"; //sheet名 if (Objects.isNull(num)) &#123; num = 65536; &#125; String[][] content = buildContent(num); long start = System.currentTimeMillis(); SXSSFWorkbook wb = ExcelUtil.getSXSSFWorkbookByPageThread(SHEET_NAME, TITLE, content, null); long millis = System.currentTimeMillis() - start; long second = millis / 1000; System.out.println(\"SXSSF Page Thread 导出\" + num + \"条数据，花费：\" + second + \"s/ \" + millis + \"ms\"); writeAndClose(response, fileName, wb); wb.dispose(); &#125; /** * 构建内容 * @param num * @return */ private String[][] buildContent(Integer num) &#123; String[][] content = new String[num][5]; for (int i = 0; i &lt; content.length; i++) &#123; content[i][0] = \"1\"; content[i][1] = \"2\"; content[i][2] = \"3\"; content[i][3] = \"4\"; content[i][4] = \"5\"; &#125; return content; &#125; private void writeAndClose(HttpServletResponse response, String fileName, Workbook wb) &#123; try &#123; this.setResponseHeader(response, fileName); OutputStream os = response.getOutputStream(); wb.write(os); os.flush(); os.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public void setResponseHeader(HttpServletResponse response, String fileName) &#123; try &#123; try &#123; fileName = new String(fileName.getBytes(), \"UTF-8\"); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; response.setContentType(\"application/octet-stream;charset=ISO8859-1\"); response.setHeader(\"Content-Disposition\", \"attachment;filename=\" + fileName); response.addHeader(\"Pargam\", \"no-cache\"); response.addHeader(\"Cache-Control\", \"no-cache\"); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125;&#125; 工具类 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class ExcelUtil &#123; public static final int PER_SHEET_LIMIT = 100000; public static SXSSFWorkbook getSXSSFWorkbookByPageThread(String sheetName, String[] title, String[][] values) &#123; SXSSFWorkbook wb = new SXSSFWorkbook(); int pageNum = values.length / PER_SHEET_LIMIT; int lastCount = values.length % PER_SHEET_LIMIT; if (values.length &gt; PER_SHEET_LIMIT) &#123; CellStyle style = wb.createCellStyle(); CountDownLatch downLatch; Executor executor; if (lastCount == 0) &#123; downLatch = new CountDownLatch(pageNum); executor = Executors.newFixedThreadPool(pageNum); &#125; else &#123; downLatch = new CountDownLatch(pageNum + 1); executor = Executors.newFixedThreadPool(pageNum + 1); &#125; for (int c = 0; c &lt;= pageNum; c++) &#123; int rowNum = PER_SHEET_LIMIT; if (c == pageNum) &#123; if (lastCount == 0) &#123; continue; &#125; rowNum = lastCount; &#125; Sheet sheet = wb.createSheet(\"page\" + c); executor.execute(new PageTask(downLatch, sheet, title, style, rowNum, values)); &#125; try &#123; downLatch.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; return wb; &#125;&#125; 分表任务类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class PageTask implements Runnable &#123; private CountDownLatch countDownLatch; private Sheet sheet; private String[] title; private CellStyle style; private int b; private String[][] values; public PageTask(CountDownLatch countDownLatch, Sheet sheet, String[] title, CellStyle style, int b, String[][] values) &#123; this.countDownLatch = countDownLatch; this.sheet = sheet; this.title = title; this.style = style; this.b = b; this.values = values; &#125; @Override public void run() &#123; try &#123; Row row = sheet.createRow(0); Cell cell = null; for (int i = 0; i &lt; title.length; i++) &#123; cell = row.createCell(i); cell.setCellValue(title[i]); cell.setCellStyle(style); &#125; for (int i = 0; i &lt; b; i++) &#123; row = sheet.createRow(i + 1); for (int j = 0; j &lt; values[i].length; j++) &#123; row.createCell(j).setCellValue(values[i][j]); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (countDownLatch != null) &#123; countDownLatch.countDown(); &#125; &#125; &#125;&#125;","link":"/2018/10/10/POI高效导出百万级Excel数据/"},{"title":"Linux常用命令","text":"作为一个有理想有逼格的后端工程师，Linux的常用命令我们是必须掌握的。这句话只是显示逼格，真实的是，Linux命令是个后台工程师就必须会的。( I think so . ) Linux权限文件及文件夹创建文件夹 mkdir 功能make directory的缩写,用于创建种子定名称的目录，要求当前用户具有写权限。 格式mkdir [选项] 目录名称 参数 -m, –mode=MODE 设定权限&lt;模式&gt; (类似 chmod) -p, –parents 若父级目录不存在，自动创建 -v, –verbose 创建后打印信息 示例mkdir -m 777 test1 mkdir -p /home/qfwang/test2 mkdir -v test3 $ mkdir: created directory &apos;test3&apos; 创建文件 touch 功能新建一个文件，或修改文件的时间戳，不是很常用。 格式touch [选项] 文件名称 参数 -a 仅更改存取时间 -c, –no-create 不创建任何文档 -d, –date=STRING 使用指定的日期时间代替当前日期时间 -m –time=modify 只更改修改时间 -r, –reference=FILE 使用指定文档的时间代替当前时间 -t STAMP 使用指定时间 示例 文件的复制 cp 功能copy的缩写，用于文件的复制，也可以多个文件复制到同一目录下。 格式cp [选项] 源…… 目标 参数 -a ：将文件的特性一起复制 -p ：连同文件的属性一起复制，而非使用默认方式，与-a相似，常用于备份 -i ：若目标文件已经存在时，在覆盖时会先询问操作的进行 -r ：递归持续复制，用于目录的复制行为 -u ：目标文件与源文件有差异时才会复制 示例 cp -a file1 file2 #连同文件的所有特性把文件file1复制成文件file2 cp file1 file2 file3 dir #把文件file1、file2、file3复制到目录dir中 列出文件 ls 功能list的缩写，用于列出当前或指定目录下的文件及文件夹- 格式ls [选项] 指定目录 参数 -l ：列出长数据串，包含文件的属性与权限数据等 -a ：列出全部的文件，连同隐藏文件（开头为.的文件）一起列出来（常用） -d ：仅列出目录本身，而不是列出目录的文件数据 -h ：将文件容量以较易读的方式（GB，kB等）列出来 -R ：连同子目录的内容一起列出（递归列出），等于该目录下的所有文件都会显示出来 示例 12345678root@java:~$ ls -ltotal 3240drwxrwxr-x 2 root root 4096 Jun 26 02:59 dashboarddrwxrwxr-x 7 root root 4096 Aug 29 03:33 dashboard-srcroot@java:~$ ls -hltotal 3.2Mdrwxrwxr-x 2 root root 4.0K Jun 26 02:59 dashboarddrwxrwxr-x 7 root root 4.0K Aug 29 03:33 dashboard-src 文件的移动 mvmv是move的缩写，该命令用于移动文件、目录。 格式mv [选项] 指定文件/目录…… 目标目录 参数 -f ：force强制的意思，如果目标文件已经存在，不会询问而直接覆盖 -i ：若目标文件已经存在，就会询问是否覆盖 -u ：若目标文件已经存在，且比目标文件新，才会更新 示例 123456789~/test » ls dfadmin@Java-testjm jm.text------------------------------------------------~/test » cp -f jm.text jm/jm1.text dfadmin@Java-test------------------------------------------------~/test » cp -i jm.text jm/jm1.text dfadmin@Java-testcp: overwrite 'jm/jm1.text'? y------------------------------------------------~/test » cp -u jm.text jm/jm1.text wen","link":"/2018/08/05/Linux常用命令/"},{"title":"设计模式-原型模式","text":"定义原型模式: 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 说到原型模式，还要了解两个概念： 浅拷贝使用一个已知实例对新创建实例的成员变量逐个赋值，这个方式被称为浅拷贝。 深拷贝当一个类的拷贝构造方法，不仅要复制对象的所有非引用成员变量值，还要为引用类型的成员变量创建新的实例，并且初始化为形式参数实例值。 结构UML图 角色 抽象原型类（Prototype）为克隆声明一个接口 具体原型类（ConcretePrototype）实现自我克隆的操作。 客户类（Client）通过要求原型类克隆自己来创建新的对象。 实现如本篇头的大圣变出无数个自己的图为例。其实不仅孙悟空能变出自己，神仙可能都能学会这个技能，于是我们抽象出一个神仙抽象接口(也可以是抽象类，但会降低子类的扩展性)。只要实现了神仙接口那么他就能够变出自己。 抽象原型类（Prototype）12345678910111213141516/** * 神仙抽象类 * * @author: flyhero * @date: 2018-09-25 下午7:18 */public interface Immortal extends Cloneable &#123; /** * 神仙会克隆出另一个自己 * * @return */ Immortal clone();&#125; 孙悟空实现了神仙接口，于是具有了克隆能力。如果八戒也想拥有克隆能力，也只要实现神仙接口即可。 具体原型类（ConcretePrototype） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 孙悟空 * @author: flyhero * @date: 2018-09-25 下午7:22 */public class Wukong implements Immortal &#123; private String weapon = \"金箍棒\"; private ArrayList&lt;String&gt; skill = new ArrayList&lt;&gt;(Arrays.asList(\"遁地术\")); //getter and setter …… /** * 克隆出另一个 * * @return */ @Override public Immortal clone() &#123; Wukong wukong = null; try &#123; wukong = (Wukong) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return wukong; &#125;&#125;/** * 八戒 * @author: flyhero * @date: 2018-09-25 下午7:43 */ public class Pigsy implements Immortal &#123; private String weapon = \"九齿钉耙\"; //getter and setter …… @Override public Immortal clone() &#123; Pigsy pigsy = null; try &#123; pigsy = (Pigsy)super.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return pigsy; &#125;&#125; 让悟空来克隆一下自己 客户端类（Client） 1234567891011121314151617/** * @author: flyhero * @date: 2018-09-25 下午7:48 */public class Client &#123; public static void main(String[] args) &#123; Wukong wukong = new Wukong(); Wukong w = (Wukong) wukong.clone(); wukong.getSkill().add(\"幻化术\"); System.out.println(wukong.getSkill().toString()); System.out.println(w.getSkill().toString()); &#125;&#125;// print [遁地术, 幻化术]// print [遁地术, 幻化术] 我们发现大圣克隆出一个大圣2号后，自己又学会了幻化术，但大圣2号莫名的也学会了幻化术，这不是我们想要的，克隆后他们应该各自独立去干不同的事情，而不应该还有这样的联系。这就是浅拷贝造成的，如何解决呢？那就是对大圣的技能集合进行深拷贝： 123456789101112131415161718192021public class Wukong implements Immortal &#123; private String weapon = \"金箍棒\"; private ArrayList&lt;String&gt; skill = new ArrayList&lt;&gt;(Arrays.asList(\"遁地术\")); //getter and setter …… @Override public Immortal clone() &#123; Wukong wukong = null; try &#123; wukong = (Wukong) super.clone(); //对集合进行深拷贝 wukong.setSkill((ArrayList)wukong.getSkill().clone()); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return wukong; &#125;&#125; 总结 使用场景需要重复创建多个相同对象时或创建的对象较为复杂。 好处向客户隐藏了创建对象的复杂性。 注意克隆时的浅拷贝和深拷贝要分清，否则很容易出错。","link":"/2018/10/15/设计模式-原型模式/"},{"title":"Java的代码执行顺序","text":"程序中代码执行的顺序非常重要，稍有不慎便会是程序运行出错，那么我将结合实例来分析代码中的执行。 名词解释首先了解几个名词： 非静态代码块直接由 { } 包起来的代码，称为非静态代码块 静态代码块直接由 static { } 包起来的代码，称为静态代码块 形参比如你定义一个函数void add（int a, int b），这里的a和b就是形参。当你进行函数调用的时候，add（1, 2），这里的1和2就是实参。 向前引用所谓向前引用，就是在定义类、接口、方法、变量之前使用它们。 成员变量在类体里面定义的变量称为成员变量； 如果该成员变量有 static 关键字修饰，则该成员变量称为 静态变量 或 类变量； 如果该成员变量没有 static 关键字修饰，则该成员变量被称为 非静态变量 或 实例变量。 局部变量形参、方法内定义的变量、代码块中定义的变量，都属于局部变量。 类变量 （静态变量）1. 可以向前引用 2. 变量属于类本身 3. 类变量不依赖类的实例，类变量只在初始化时候在方法区中被分配一次空间，无论类的实例被创建几次，都不再为类变量分配空间 4. 通过类的任意一个实例来访问类变量，底层都将将其转为通过类本身来访问类变量，它们的效果是一样的 5. 一旦类变量的值被改变，通过类或类的任意一个实例来访问类变量，得到的都将是被改变后的值 6. 将在类的初始化之前初始化 实例变量（非静态变量）1. 不能向前引用，如果向前引用，则称为非法向前引用，这是不允许的 2. 变量属于类的实例对象 3. 随着类的实例被创建而分配内存空间 实例演示12345678910111213141516171819202122232425262728293031323334353637383940public class Parent &#123; public int parentNum=0; public static int staticParentNum=0; &#123; System.out.println(\"Parent---执行非静态代码块了1！\"); &#125; &#123; System.out.println(\"Parent---执行非静态代码块了2！\"); &#125; static&#123; System.out.println(\"Parent---执行静态代码块了1！\"); &#125; static&#123; System.out.println(\"Parent---执行静态代码块了2！\"); &#125; public Parent()&#123; System.out.println(\"Parent---无参构造函数！\"); &#125; public Parent(int parentNum)&#123; this.parentNum=parentNum; System.out.println(\"Parent---有参构造函数！\"); &#125; public void ParentMethod(int parentNum)&#123; this.parentNum=parentNum; System.out.println(\"Parent---非静态方法/parentNum=\"+parentNum); &#125; public static void staticParentMethod(int staticParentNum)&#123; Parent.staticParentNum=staticParentNum; System.out.println(\"Parent---静态方法/staticParentNum=\"+staticParentNum); &#125; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Child extends Parent&#123; public int childNum=0; public static int staticChildNum=0; &#123; System.out.println(\"Child---执行非静态代码块了1！\"); &#125; &#123; System.out.println(\"Child---执行非静态代码块了2！\"); &#125; static&#123; System.out.println(\"Child---执行静态代码块了1！\"); &#125; static&#123; System.out.println(\"Child---执行静态代码块了2！\"); &#125; public Child()&#123; super(); System.out.println(\"Child---无参构造函数！\"); &#125; public Child(int childNum)&#123; super(childNum); System.out.println(\"Child---有参构造函数！\"); &#125; public void childMethod(int childNum)&#123; this.childNum=childNum; System.out.println(\"Child--非静态方法/childNum=\"+childNum); &#125; public static void staticChildMethod(int staticChildNum)&#123; Child.staticChildNum=staticChildNum; System.out.println(\"Child---静态方法/staticChildNum=\"+staticChildNum); &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136package test;public class Test &#123;// static&#123;// System.out.println(&quot;Test---静态代码块！&quot;);// &#125; public static void main(String[] args) &#123; int key=10; switch (key) &#123; case 0: Parent parent=new Parent(); break;// Parent---执行静态代码块了1！// Parent---执行静态代码块了2！// Parent---执行非静态代码块了1！// Parent---执行非静态代码块了2！// Parent---无参构造函数！// 说明：先加载静态代码块，后加载非静态代码块 case 1: Child b= new Child(); break;// Parent---执行静态代码块了1！// Parent---执行静态代码块了2！// Child---执行静态代码块了1！// Child---执行静态代码块了2！// Parent---执行非静态代码块了1！// Parent---执行非静态代码块了2！// Parent---无参构造函数！// Child---执行非静态代码块了1！// Child---执行非静态代码块了2！// Child---无参构造函数！// 说明：创建子类，会先执行父类，先执行父类静态——&gt;子类静态——&gt;父类非静态——&gt;父类构造——&gt;子类非静态——&gt;子类构造 case 2: Child c= new Child(4); //这个构造函数中指明了调用父类的有参构造函数，若不指定，则调用父类无参构造函数 break;// Parent---执行静态代码块了1！// Parent---执行静态代码块了2！// Child---执行静态代码块了1！// Child---执行静态代码块了2！// Parent---执行非静态代码块了1！// Parent---执行非静态代码块了2！// Parent---有参构造函数！// Child---执行非静态代码块了1！// Child---执行非静态代码块了2！// Child---有参构造函数！ 说明：静态代码块或非静态代码块执行顺序，按照代码前后编写顺序。 case 3: Child d= new Child(); Child e= new Child(4); break;// Parent---执行静态代码块了1！// Parent---执行静态代码块了2！// Child---执行静态代码块了1！// Child---执行静态代码块了2！// Parent---执行非静态代码块了1！// Parent---执行非静态代码块了2！// Parent---无参构造函数！// Child---执行非静态代码块了1！// Child---执行非静态代码块了2！// Child---无参构造函数！// Parent---执行非静态代码块了1！// Parent---执行非静态代码块了2！// Parent---有参构造函数！// Child---执行非静态代码块了1！// Child---执行非静态代码块了2！// Child---有参构造函数！ 说明：创建多个子类，但父类静态代码块只执行一次。 case 4: Child.staticChildMethod(4); break;// Parent---执行静态代码块了1！// Parent---执行静态代码块了2！// Child---执行静态代码块了1！// Child---执行静态代码块了2！// Child---静态方法/staticChildNum=4 说明：静态方法只可以调用静态变量。 case 5: Parent.staticParentMethod(5); break;// Parent---执行静态代码块了1！// Parent---执行静态代码块了2！// Parent---静态方法/staticParentNum=5 说明：静态方法可通过 父类名.静态方法() 调用。 case 6: System.out.println(&quot;父类的静态变量值staticParentNum=&quot;+Parent.staticParentNum); break;// Parent---执行静态代码块了1！// Parent---执行静态代码块了2！// 父类的静态变量值staticParentNum=0 说明：调用静态变量时，静态代码块会执行。 case 7: System.out.println(&quot;子类的静态变量值staticChildNum=&quot;+Child.staticChildNum); break;// Parent---执行静态代码块了1！// Parent---执行静态代码块了2！// Child---执行静态代码块了1！// Child---执行静态代码块了2！// 子类的静态变量值staticChildNum=0 说明：调用子类静态变量，父类静态代码块和子类静态代码块会被执行。 case 8: System.out.println(&quot;父类的静态变量值staticParentNum=&quot;+Parent.staticParentNum); System.out.println(&quot;子类的静态变量值staticChildNum=&quot;+Child.staticChildNum); break;// Parent---执行静态代码块了1！// Parent---执行静态代码块了2！// 父类的静态变量值staticParentNum=0// Child---执行静态代码块了1！// Child---执行静态代码块了2！// 子类的静态变量值staticChildNum=0 case 9: Child f= new Child(); f.ParentMethod(3); break;// Parent---执行静态代码块了1！// Parent---执行静态代码块了2！// Child---执行静态代码块了1！// Child---执行静态代码块了2！// Parent---执行非静态代码块了1！// Parent---执行非静态代码块了2！// Parent---无参构造函数！// Child---执行非静态代码块了1！// Child---执行非静态代码块了2！// Child---无参构造函数！// Parent---非静态方法/parentNum=3 说明：创建子类，用子类调用父类方法，非静态方法可以调用静态变量。 default: break; &#125; &#125;&#125; 总结Java代码初始化顺序： 1. 由 static 关键字修饰的（如：类变量(静态变量)、静态代码块）将在类被初始化创建实例对象之前被初始化，而且是按顺序从上到下依次被执行。静态（类变量、静态代码块）属于类本身，不依赖于类的实例。 2. 没有 static 关键字修饰的（如：实例变量(非静态变量)、非静态代码块）初始化实际上是会被提取到类的构造器中被执行的，但是会比类构造器中的代码块优先执行到，非静态（实例变量、非静态代码块）的地位是相等的，它们将按顺序被执行。 类变量（静态变量）、实例变量（非静态变量）、静态代码块、非静态代码块的初始化时机 由 static 关键字修饰的（如：类变量[静态变量]、静态代码块）将在类被初始化创建实例对象之前被初始化，而且是按顺序从上到下依次被执行； 没有 static 关键字修饰的（如：实例变量[非静态变量]、非静态代码块）初始化实际上是会被提取到类的构造器中被执行的，但是会比类构造器中的 代码块优先执行到，其也是按顺序从上到下依次被执行。 容易混淆的一个知识点 静态方法只允许直接访问静态成员，而实例方法中可以访问静态成员和实例成员，原因是类还没有实例化，所实例成员也没有被创建，静态方法中因此也不能用this。","link":"/2016/07/25/Java的代码执行顺序/"},{"title":"Spring事务传播和事务隔离","text":"事务可以帮助我们避免许多数据不一致性的问题。 什么是事务传播？就是一个事务中遇到其它事务，spring该如何来处理这些事务的行为。 什么是事务隔离？假若两个事务同时对同一数据进行操作，为了有效保证并发读取数据的正确性，spring对这些情况的进行处理。 两者对比对比事务传播和事务隔离来讲：（如有不妥，请指出） 传播是顺序进行的 隔离是同时进行的 用图来说明获取更加形象 如果你了解脏读，幻读，不可重复读的话，那事务隔离更加容易理解了。 知道了什么是事务传播和隔离，那么我们来看事务传播和隔离都有哪些？ 事务的传播行为在Spring 的事务中， 可以通过 propagation 来定义事务的传播行为： 名称 意义 PROPAGATION_REQUIRED 若当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中（常用） PROPAGATION_SUPPORTS 支持当前事务，如果当前没有事务，就以非事务方式执行（常用） PROPAGATION_REQUIRES_NEW 新建事务，如果当前存在事务，把当前事务挂起（常用） PROPAGATION_MANDATORY 使用当前的事务，如果当前没有事务，就抛出异常。 PROPAGATION_NOT_SUPPORTED 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 PROPAGATION_NEVER 以非事务方式执行，如果当前存在事务，则抛出异常 PROPAGATION_NESTED 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与 PROPAGATION_REQUIRED类似的操作。 隔离界别在Spring 的事务中， 可以通过 isolation 来定义。 该隔离界别主要定义了一个事务和其他事务进行的资源或者数据更改相隔离的程度。 名称 意义 脏读 幻读 不可重复读 ISOLATION_DEFAULT 默认的隔离级别，使用数据库默认的事务隔离级别. ISOLATION_READ_UNCOMMITTED 这是事务最低的隔离级别，它充许令外一个事务可以看到这个事务未提交的数据。 √ √ √ OLATION_READ_COMMITTED 保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。 × √ √ ISOLATION_REPEATABLE_READ 它保证一个事务不能读取另一个事务未提交的数据外，还避免不可重复读的情况产生。 × √ × ISOLATION_SERIALIZABLE 这是花费最高代价但是最可靠的事务隔离级别，事务被处理为顺序执行。除了防止脏读，不可重复读外，还避免了幻像读。 × × × MySQL 事务隔离级别 名称 脏读 幻读 不可重复读 读未提交 READ UNCOMMITTED √ √ √ 读已提交 READ COMMITTED × √ √ 可重复读 REPEATABLE READ × √ × 可串行化 SERIALIZABLE × × × 在MySQL数据库中，支持上面四种隔离级别，默认的为Repeatable read (可重复读)； 在Oracle数据库中，只支持Serializable (串行化)级别和Read committed (读已提交)这两种级别，其中默认的为Read committed级别。 脏读，幻读，不可重复读 名称 意义 脏读 指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是脏数据，依据脏数据所做的操作可能是不正确的。 幻读 指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。 不可重复读 指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。 举例 理解spring事务传播假如userService.deleteUser()事务中调用了scoreService.deleteScore()方法。 123456//UserService.javapublic void deleteUser(int id)&#123; userDao.delete(id); scoreService.deleteScore(id);&#125; 若两个方都是spring默认事务传播，当执行userService.deleteUser()的时候spring已经起了事务，这时调用 scoreService.deleteScore()，scoreService.deleteScore() 看到自己已经运行在 userService.deleteUser()的事务内部，就不再起新的事务。 若userService.deleteUser()没有事务，那么scoreService.deleteScore() 运行的时候发现自己没有在事务中，它就会为自己分配一个事务。 这样，在userService.deleteUser() 或者在scoreService.deleteScore() 内的任何地方出现异常，事务都会被回滚。 若userService.deleteUser()的事务级别为 PROPAGATION_REQUIRED；scoreService.deleteScore() 的事务级别为 PROPAGATION_REQUIRES_NEW。 那么当执行到scoreService.deleteScore() 的时候，userService.deleteUser() 所在的事务就会挂起，scoreService.deleteScore() 会起一个新的事务，等待 scoreService.deleteScore()的事务完成以后，它才继续执行。 PROPAGATION_REQUIRES_NEW与 PROPAGATION_REQUIRED 的事务区别在于事务的回滚程度了。因为 scoreService.deleteScore() 是新起一个事务，那么就是存在两个不同的事务。如果 scoreService.deleteScore()已经提交，那么userService.deleteUser() 失败回滚，scoreService.deleteScore()是不会回滚的。如果scoreService.deleteScore() 失败回滚，如果他抛出的异常被userService.deleteUser()捕获，userService.deleteUser()事务仍然可能提交(主要看B抛出的异常是不是A会回滚的异常)。 scoreService.deleteScore()的事务级别为 PROPAGATION_SUPPORTS，那么当执行到scoreService.deleteScore()时，如果发现userService.deleteUser()已经开启了一个事务，则加入当前的事务，如果发现userService.deleteUser()没有开启事务，则自己也不开启事务。这种时候，内部方法的事务性完全依赖于最外层的事务。 5.若scoreService.deleteScore()的事务属性被配置为 PROPAGATION_NESTED, 此时两者之间又将如何协作呢? scoreService.deleteScore()如果回滚, 那么内部事务(即 scoreService.deleteScore()) 将回滚到它执行前的 SavePoint 而外部事务(即 userService.deleteUser()) 可以有以下两种处理方式: a、捕获异常，执行异常分支逻辑 1234567public void deleteUser() &#123; try &#123; scoreService.deleteScore(); &#125; catch (Exception e) &#123; // 执行其他业务 &#125; &#125; 这种方式也是嵌套事务最有价值的地方, 它起到了分支执行的效果, 如果scoreService.deleteScore()失败, 那么执行其他业务, 而scoreService.deleteScore()已经回滚到它执行之前的保存点(SavePoint), 所以不会产生脏数据(相当于此方法从未执行过), 这种特性可以用在某些特殊的业务中, 而 PROPAGATION_REQUIRED 和 PROPAGATION_REQUIRES_NEW 都没有办法做到这一点。 b、 外部事务回滚/提交 代码不做任何修改, 如果内部事务回滚, 那么首先它将回滚到它执行之前的 保存点(SavePoint)(在任何情况下都会如此), 外部事务将根据具体的配置决定自己是提交还是回滚。 保存点（savepoint）是事务过程中的一个逻辑点，我们可以把事务回退到这个点，而不必回退整个事务。 如何在Spring框架中使用声明式事务？Spring的声明式事务管理是基于AOP的，而AOP是通过动态代理实现的。动态代理的一个重要特征是：它是针对接口的，所以如果dao或者service要通过动态代理让Spring接管事务，就必须在dao或者service抽象一个接口。常见的形式比如： 12接口类：UserService实现类：UserServiceImpl 当然如果没有这样的接口，那么Spring会使用CGLib来解决问题，但这不是Spring推荐的方式。 基于@Transactional的声明式事务管理Spring引入了基于 Annotation 的方式，具体主要涉及 @Transactional 标注。 在spring的xml配置文件中加入以下内容：spring-service.xml 123456789101112&lt;!-- 扫描service包下所有使用注解的类型 --&gt;&lt;context:component-scan base-package=&quot;com.flyhero.flyapi.service.impl&quot; /&gt;&lt;!-- 配置事务管理器 --&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;&lt;/bean&gt;&lt;!-- 配置基于注解的声明式事务 --&gt;&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot; /&gt; @Transactional 可以作用于接口、接口方法、类以及类方法上。当作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。 1234567@Transactionalpublic interface UserService &#123; //将覆盖接口上的事务 @Transactional(propagation=Propagation.REQUIRED) User findById(int id); &#125; 123456789@Transactionalpublic class ScoreServiceImpl&#123; //将覆盖类上的事务 @Transactional(propagation=Propagation.REQUIRED) public int insert(User user) &#123; int num=userMapper.insertSelective(user); return num; &#125;&#125; 虽然 @Transactional 注解可以作用于接口、接口方法、类以及类方法上，但是 Spring 建议不要在接口或者接口方法上使用该注解，因为这只有在使用基于接口的代理时它才会生效。另外， @Transactional 注解应该只被应用到 public 方法上，这是由 Spring AOP 的本质决定的。如果你在 protected、private 或者默认可见性的方法上使用 @Transactional 注解，这将被忽略，也不会抛出任何异常。 基于tx命名空间的声明式事务管理在spring的xml配置文件中加入以下内容：spring-service.xml12345678910111213141516171819202122232425 &lt;!--配置事务管理器 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;defaultDataSource&quot; /&gt;&lt;/bean&gt;&lt;!--拦截器方式配置事物 --&gt; &lt;tx:advice id=&quot;transactionAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;add*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;insert*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;delete*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;modify*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;find*&quot; propagation=&quot;SUPPORTS&quot; /&gt; &lt;tx:method name=&quot;query*&quot; propagation=&quot;SUPPORTS&quot; /&gt; &lt;tx:method name=&quot;search*&quot; propagation=&quot;SUPPORTS&quot; /&gt; &lt;tx:method name=&quot;*&quot; propagation=&quot;SUPPORTS&quot; /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt;&lt;aop:config expose-proxy=&quot;true&quot;&gt; &lt;!-- 只对业务逻辑层实施事务 --&gt; &lt;aop:pointcut id=&quot;transactionPointcut&quot; expression=&quot;execution(* com.flyhero.flyapi.service.*.*(..))&quot; /&gt; &lt;!--Advisor定义，切入点和通知分别为transactionPointcut、transactionAdvice --&gt; &lt;aop:advisor pointcut-ref=&quot;transactionPointcut&quot; advice-ref=&quot;transactionAdvice&quot;/&gt; &lt;/aop:config&gt; execution(* com.flyhero.flyapi.service.*.*(..))代码当中第一个 为定义通配 返回值类型；第二个 为定义通配 com.flyhero.flyapi.service包中所有类；第三个* 为定义通配 类中的任意方法。第四(..) 为定义方法中可以有任意参数。 这样我们就不需要在方法上使用@Transactional注解了。 注解方式和命名空间方式对比 方式 优点 缺点 注解方式 使用起来非常简单明了，没有学习成本 必须在每一个需要使用事务的方法或者类上用 @Transactional 标注 命名空间方式 与切点表达式结合，功能强大，利用切点表达式，一个配置可以匹配多个方法 配置较多，对于新手易出错 项目中遇到的问题： @Transactional 遇上 try catch","link":"/2017/06/28/Spring事务传播和事务隔离/"},{"title":"Spring MVC入门示例","text":"本文由flyhero翻译 在这个例子中，我们将使用SpringMVC框架构建一个hello world的web应用程序。SpringMVC是Spring框架中最重要的模块之一。它以强大的Spring IOC容器为基础并且充分的利用容器的特征来简化它的配置。 目录表 什么是MVC框架？ Dispatcher Servlet(Spring Controller) Spring MVC Hello World例子 运行时依赖 配置web.xml和spring-servlet.xml文件 请求处理器EmployeeController.java 视图模型EmployeeVO.java Dao层类 Service层类 视图employeesListDisplay.jsp 什么是MVC框架？Model-view-controller (MVC) 是一个众所周知的以应用程序为基础的界面设计的设计模式。在一个应用程序中，它主要是从UI中解耦业务逻辑通过分离model,view,和controller的作用。通常，models是负责为当前视图封装应用程序数据。views仅应该展现这些数据，并不包含任何业务逻辑。controller是负责接收用户的请求并调用后端services（manager or dao）进行业务逻辑处理。处理之后，后端services可能返回一些数据供views展示。Controllers 收集这些数据并且准备models给view展示。MVC模式的核心思想是从UI中分析业务逻辑以允许它们各自改变而不相互影响。在一个SpringMVC应用程序中，models通常由POJO对象组成，它被service层处理，在持久层被持久化。Views通常是用Java Standard Tag Library(JSTL)写的JSP模板。Controller 部分是由dispatcher servlet来管理，我们将在这个教程中学习更多细节。 一些开发者认为service层和DAO层类在MVC中是model的组成部分，在这里我有不同的观点。我不认为service层和DAO层类是MVC框架中的部分。通常一个web应用程序是3层架构，即data-service-presentation。MVC通常是表现层(presentation )的一部分。 Dispatcher Servlet (Spring Controller)在最简单的Spring MVC应用程序中，你需要在一个Java web部署描述（即web.xml）中配置的唯一的servlet。一个Spring MVC controller ——经常被叫做一个实现front controller设计模式的Dispatcher Servlet，并且每个web请求必须通过它以至于它能管理所有的请求生命周期。 当一个web请求发送到一个Spring MVC应用程序时，dispatcher servlet首先接收这个请求。然后，它将在Spring’s web应用上下文中组织不同的组件配置（例如：真实的请求处理控制器和视图解析器）或者在controller本身中注解目前所有需要处理的请求。 为了在Spring 3.0中定义一个controller类，类不得不被@Controller注解标记。当一个带有@Controller注解的controller接收一个请求，它会寻找一个适合的处理方法来处理请求。这就需要一个controller类映射每个请求到一个处理方法，通过一个或多个处理映射。为了如此，一个controller类的方法会被@RequestMapping注解来修饰，使它们成为处理方法。 一个处理方法处理请求完成后，它将控制权委托给视图，表示为处理方法的返回值。为了提供一个灵活的方法，一个处理方法的返回值不代表一个视图的实现，但是相当于一个没有任何的文件扩展的逻辑视图。你能够映射这些逻辑视图到正确的实现到applicationContext文件以至于你可以容易的改变你的视图层而没有接触请求处理的类代码。 为了解决一个逻辑名称匹配正确的文件，这是视图解析器（view resolvers）的责任。一旦controller类把视图名称解析到一个视图实现，它会根据每个视图的实现设计来渲染对象。 Hello World例子在这个应用程序中，我创建了最简单的员工管理程序示例，它仅有一个功能即在系统中列出所有的在职员工。让我们来看下面这个应用程序的目录结构。现在来让我们来写所有有关的文件到这个hello world应用中。 pom.xml 下面 pom.xml 文件包含了 spring mvc的依赖和写Jsp文件的标签库。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.howtodoinjava.demo&lt;/groupId&gt; &lt;artifactId&gt;springmvcexample&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;springmvcexample Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring MVC support --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.1.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.1.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Tag libs support for view layer --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;springmvcexample&lt;/finalName&gt; &lt;/build&gt;&lt;/project&gt; web.xml 这个最简web.xml文件声明一个servlet（即dispatcher servlet）用于接收所有种类的请求。dispatcher servlet这里充当前置控制器。 12345678910111213141516171819202122&lt;web-app id=&quot;WebApp_ID&quot; version=&quot;2.4&quot; xmlns=&quot;http://java.sun.com/xml/ns/j2ee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd&quot;&gt; &lt;display-name&gt;Spring Web MVC Hello World Application&lt;/display-name&gt; &lt;servlet&gt; &lt;servlet-name&gt;spring&lt;/servlet-name&gt; &lt;servlet-class&gt; org.springframework.web.servlet.DispatcherServlet &lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;spring&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; spring-servlet.xml (你也能够使用applicationContext.xml文件) 我们在请求handler、service、dao层使用带注解的类，所以在基础的包中我对所有的类文件进行注解处理。“com.howtodoinjava.demo“12345678910111213141516171819&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context/ http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.howtodoinjava.demo&quot; /&gt; &lt;bean class=&quot;org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping&quot; /&gt; &lt;bean class=&quot;org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter&quot; /&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot; /&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; EmployeeController.java 在类和方法上注解@RequestMapping来决定URL在哪个方法会被调用。12345678910111213141516171819202122import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import com.howtodoinjava.demo.service.EmployeeManager;@Controller@RequestMapping(&quot;/employee-module&quot;)public class EmployeeController &#123; @Autowired EmployeeManager manager; @RequestMapping(value = &quot;/getAllEmployees&quot;, method = RequestMethod.GET) public String getAllEmployees(Model model) &#123; model.addAttribute(&quot;employees&quot;, manager.getAllEmployees()); return &quot;employeesListDisplay&quot;; &#125;&#125; 更多关于： How to use @Component, @Repository, @Service and @Controller Annotations? EmployeeVO.java 这个类充当MVC模式的model。 1234567891011121314151617181920package com.howtodoinjava.demo.model;import java.io.Serializable;public class EmployeeVO implements Serializable &#123; private static final long serialVersionUID = 1L; private Integer id; private String firstName; private String lastName; //Setters and Getters @Override public String toString() &#123; return \"EmployeeVO [id=\" + id + \", firstName=\" + firstName + \", lastName=\" + lastName + \"]\"; &#125;&#125; EmployeeDAO.java 这个类在三层结构中是第三层，负责与底层数据库的交互。 12345678import java.util.List;import com.howtodoinjava.demo.model.EmployeeVO;public interface EmployeeDAO &#123; public List&lt;EmployeeVO&gt; getAllEmployees();&#125; EmployeeDAOImpl.java 1234567891011121314151617181920212223242526272829import java.util.ArrayList;import java.util.List;import org.springframework.stereotype.Repository;import com.howtodoinjava.demo.model.EmployeeVO;@Repositorypublic class EmployeeDAOImpl implements EmployeeDAO &#123; public List&lt;EmployeeVO&gt; getAllEmployees() &#123; List&lt;EmployeeVO&gt; employees = new ArrayList&lt;EmployeeVO&gt;(); EmployeeVO vo1 = new EmployeeVO(); vo1.setId(1); vo1.setFirstName(\"Lokesh\"); vo1.setLastName(\"Gupta\"); employees.add(vo1); EmployeeVO vo2 = new EmployeeVO(); vo2.setId(2); vo2.setFirstName(\"Raj\"); vo2.setLastName(\"Kishore\"); employees.add(vo2); return employees; &#125;&#125; EmployeeManager.java 这个类在三层架构中属于第二层，负责与DAO层的交互。12345678import java.util.List;import com.howtodoinjava.demo.model.EmployeeVO;public interface EmployeeManager &#123; public List&lt;EmployeeVO&gt; getAllEmployees();&#125; EmployeeManagerImpl.java12345678910111213141516171819import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import com.howtodoinjava.demo.dao.EmployeeDAO;import com.howtodoinjava.demo.model.EmployeeVO;@Servicepublic class EmployeeManagerImpl implements EmployeeManager &#123; @Autowired EmployeeDAO dao; public List&lt;EmployeeVO&gt; getAllEmployees() &#123; return dao.getAllEmployees(); &#125;&#125; employeesListDisplay.jsp 这个jsp用于展示系统中所有的员工。它循环遍历员工集合，并且输出他们的详细到表格中。这符合MVC的视图层。 12345678910111213141516171819202122232425262728&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt;&lt;%@ taglib prefix=&quot;fmt&quot; uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot;%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Spring MVC Hello World&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;All Employees in System&lt;/h2&gt; &lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;th&gt;Employee Id&lt;/th&gt; &lt;th&gt;First Name&lt;/th&gt; &lt;th&gt;Last Name&lt;/th&gt; &lt;/tr&gt; &lt;c:forEach items=&quot;$&#123;employees&#125;&quot; var=&quot;employee&quot;&gt; &lt;tr&gt; &lt;td&gt;$&#123;employee.id&#125;&lt;/td&gt; &lt;td&gt;$&#123;employee.firstName&#125;&lt;/td&gt; &lt;td&gt;$&#123;employee.lastName&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 现在部署应用程序到你的服务器（我使用的是tomcat 7）。并且点击URL“http://localhost:8080/springmvcexample/employee-module/getAllEmployees”。如果你正确配置所有，你会看到下面屏幕。 源码下载 在这个教程中，如果它不为你工作或是不清楚的，那么给我留言评论。","link":"/2016/08/30/Spring-MVC入门示例/"},{"title":"一举拿下String","text":"字符串广泛应用 在Java 编程中，在 Java 中字符串属于对象，Java 提供了 String 类来创建和操作字符串。 1. String 简介String定义: 12public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;&#125; 1.1 为什么设计为不可变类呢？ String设计为不可变类主要考虑到：效率和安全。 效率：1.在早期的JVM实现版本中，被final修饰的方法会被转为内嵌调用以提升执行效率。而从Java SE5/6开始，就渐渐摈弃这种方式了。因此在现在的Java SE版本中，不需要考虑用final去提升方法调用效率。只有在确定不想让该方法被覆盖时，才将方法设置为final。2.缓存hashcode，String不可变，所以hashcode不变，这样缓存才有意义，不必重新计算。 安全：String常被作为网络连接，文件操作等参数类型，倘若可改变，会出现意想不到的结果。 2. 测试掌握程度为了不浪费你的时间，请看下面的题目，若你一目了然，可以跳过本文了。 12345678910111213141516171819String str1 = \"HelloFlyapi\";String str2 = \"HelloFlyapi\";String str3 = new String(\"HelloFlyapi\");String str4 = \"Hello\";String str5 = \"Flyapi\";String str6 = \"Hello\" + \"Flyapi\";String str7 = str4 + str5;logger.info(\"str1 == str2 result: &#123;&#125;\",str1 == str2);logger.info(\"str1 == str3 result: &#123;&#125;\",str1 == str3);logger.info(\"str1 == str6 result: &#123;&#125;\",str1 == str6);logger.info(\"str1 == str7 result: &#123;&#125;\",str1 == str7);logger.info(\"str1 == str7.intern() result: &#123;&#125;\",str1 == str7.intern());logger.info(\"str3 == str3.intern() result: &#123;&#125;\",str3 == str3.intern()); 3. String 的创建方式从上面的题中你会知道，String的创建方式有两种： 3.1 直接赋值 此方式在方法区中字符串常量池中创建对象1String str = &quot;flyapi&quot;; 3.2 构造器 此方式在堆内存创建对象 1String str = new String(); 4. 分析要理解String，那么要了解JVM内存中的栈(stack)、堆(heap)和方法区。简要图（详细可查看另一篇文章）如下： str1 == str2 1234String str1 = &quot;HelloFlyapi&quot;;String str2 = &quot;HelloFlyapi&quot;;System.out.println(str1 == str2); // true 当执行第一句时，JVM会先去常量池中查找是否存在HelloFlyapi，当存在时直接返回常量池里的引用；当不存在时，会在字符创常量池中创建一个对象并返回引用。 当执行第二句时，同样的道理，由于第一句已经在常量池中创建了，所以直接返回上句创建的对象的引用。 str1 == str3 1234String str1 = \"HelloFlyapi\";String str3 = new String(\"HelloFlyapi\");System.out.println(str1 == str3); // false 执行第一句，同上第一句。 执行第二句时，会在堆（heap）中创建一个对象，当字符创常量池中没有‘HelloFlyapi’时，会在常量池中也创建一个对象；当常量池中已经存在了，就不会创建新的了。 str1 == str6 1234String str1 = \"HelloFlyapi\";String str6 = \"Hello\" + \"Flyapi\";System.out.println(str1 == str6); // true 由于”Hello”和”Flyapi”都是常量，编译时，第二句会被自动编译为‘String str6 = “HelloFlyapi”;’ str1 == str7 123456String str1 = \"HelloFlyapi\";String str4 = \"Hello\";String str5 = \"Flyapi\";String str7 = str4 + str5;System.out.println(str1 == str7); // false 其中前三句变量存储的是常量池中的引用地址。 第四句执行时，JVM会在堆（heap）中创建一个以str4为基础的一个StringBuilder对象，然后调用StringBuilder的append()方法完成与str5的合并，之后会调用toString()方法在堆（heap）中创建一个String对象，并把这个String对象的引用赋给str7。 5. 常用方法下面是 String 类支持的方法，更多详细，参看 Java String API 文档: 方法 描述 char charAt(int index) 返回指定索引处的 char 值。 int compareTo(Object o) 把这个字符串和另一个对象比较。 int compareTo(String anotherString) 按字典顺序比较两个字符串。 int compareToIgnoreCase(String str) 按字典顺序比较两个字符串，不考虑大小写。 String concat(String str) 将指定字符串连接到此字符串的结尾。 boolean contentEquals(StringBuffer sb) 当且仅当字符串与指定的StringButter有相同顺序的字符时候返回真。 static String copyValueOf(char[] data) 返回指定数组中表示该字符序列的 String。 static String copyValueOf(char[] data, int offset, int count) 返回指定数组中表示该字符序列的 String。 boolean endsWith(String suffix) 测试此字符串是否以指定的后缀结束。 boolean equals(Object anObject) 将此字符串与指定的对象比较。 boolean equalsIgnoreCase(String anotherString) 将此 String 与另一个 String 比较，不考虑大小写。 byte[] getBytes() 使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。 byte[] getBytes(String charsetName) 使用指定的字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。 void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) 将字符从此字符串复制到目标字符数组。 int hashCode() 返回此字符串的哈希码。 int indexOf(int ch) 返回指定字符在此字符串中第一次出现处的索引。 int indexOf(int ch, int fromIndex) 返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。 int indexOf(String str) 返回指定子字符串在此字符串中第一次出现处的索引。 int indexOf(String str, int fromIndex) 返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。 String intern() 返回字符串对象的规范化表示形式。 int lastIndexOf(int ch) 返回指定字符在此字符串中最后一次出现处的索引。 int lastIndexOf(int ch, int fromIndex) 返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行反向搜索。 int lastIndexOf(String str) 返回指定子字符串在此字符串中最右边出现处的索引。 int lastIndexOf(String str, int fromIndex) 返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。 int length() 返回此字符串的长度。 boolean matches(String regex) 告知此字符串是否匹配给定的正则表达式。 boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len) 测试两个字符串区域是否相等。 boolean regionMatches(int toffset, String other, int ooffset, int len) 测试两个字符串区域是否相等。 String replace(char oldChar, char newChar) 返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。 String replaceAll(String regex, String replacement) 使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。 String replaceFirst(String regex, String replacement) 使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。 String[] split(String regex) 根据给定正则表达式的匹配拆分此字符串。 String[] split(String regex, int limit) 根据匹配给定的正则表达式来拆分此字符串。 boolean startsWith(String prefix) 测试此字符串是否以指定的前缀开始。 boolean startsWith(String prefix, int toffset) 测试此字符串从指定索引开始的子字符串是否以指定前缀开始。 CharSequence subSequence(int beginIndex, int endIndex) 返回一个新的字符序列，它是此序列的一个子序列。 String substring(int beginIndex) 返回一个新的字符串，它是此字符串的一个子字符串。 String substring(int beginIndex, int endIndex) 返回一个新字符串，它是此字符串的一个子字符串。 char[] toCharArray() 将此字符串转换为一个新的字符数组。 String toLowerCase() 使用默认语言环境的规则将此 String 中的所有字符都转换为小写。 String toLowerCase(Locale locale) 使用给定 Locale 的规则将此 String 中的所有字符都转换为小写。 String toString() 返回此对象本身（它已经是一个字符串！）。 String toUpperCase() 使用默认语言环境的规则将此 String 中的所有字符都转换为大写。 String toUpperCase(Locale locale) 使用给定 Locale 的规则将此 String 中的所有字符都转换为大写。 String trim() 返回字符串的副本，忽略前导空白和尾部空白。 static String valueOf(primitive data type x) 返回给定data type类型x参数的字符串表示形式。 6. String相关由于String的不可变性导致，字符串变更时效率低下，在之后得JDK版本中出现了StringBuilder和StringBuffer. 类 可变性 线程安全 String 不可变 安全 StringBuffer 可变 安全 StringBuilder 可变 非安全 7. 常见String面试题 String str = new String(“abc”)创建了多少个对象？ 这个问题其实是不严谨的，但面试一般会遇到，所以我们要补充来说明。 类的加载和执行要分开来讲： 当加载类时，”abc”被创建并驻留在了字符创常量池中（如果先前加载中没有创建驻留过）。 当执行此句时，因为”abc”对应的String实例已经存在于字符串常量池中，所以JVM会将此实例复制到会在堆（heap）中并返回引用地址。 通过字节码我们可以看到：1234567Code: 0: new #2 // class java/lang/String 3: dup 4: ldc #3 // String wang 6: invokespecial #4 // Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V 9: astore_1 10: return 执行时仅创建了一个对象。 关于这个面试题，可以看看一个超大牛的回答：http://rednaxelafx.iteye.com/blog/774673","link":"/2018/03/11/一举拿下String/"},{"title":"【读】Java核心技术卷1","text":"看到这本书时，我的内心是崩溃的，卷1就700多页，但是这本书是很多前辈所推荐的，想必其中必有精华所在，硬着头皮上吧。 阅读方式 拿到书的第一眼肯定去看目录，大概了解一下，各个章节所讲内容。 为表对作者的尊重，快读扫读了，译者序、前言和致谢。 通过目录了解到，第1，2章所讲概述和环境搭建，对于我来说没有价值，选择忽略。 第10，11，12，13章所讲Java图形界面相关，当今这方面几乎很少使用，选择忽略。 由于并不是Java新手，所以我将选择对我有益的知识点进行记录。 最后读完，应该总结成思维导图。 第三章 Java的基本程序设计结构长整型 long a = 3.14L 这里注意要用大写的L作为后缀，因为小写 l 有时很像数字 1 浮点型 单精度类型表示：float a = 3.14F 或 3.14f 双精度类型的表示：double b = 3.14D 或 3.14f 注意：当浮点型数字没有后缀时（如：3.14），默认为double类型。另外浮点数值不适用于无法接受舍入误差的金融计算中，如 2.0 - 1.1 结果是 0.89999999999999，为更精确的计算，可以使用BigDecimal类。 有三个特殊的浮点型数值： 正无穷大 负无穷大 NaN （不是一个数字）正整数除以0的结果正无穷大(如：3/0.0 结果为Infinity)，Infinity表示无穷大的概念，0.0并不是真正意义上的0，它只是非常接近0而已。，0/0或者负数的平方根结果为NaN.(如：0.0/0.0 ，Math.sqrt(-3)结果为 NaN )，对于所有没有良好的数字定义的浮点计算，例如0.0/0.0，或者对负数求平方根其值都是它. 结合赋值和运算符 x = x + 4简写： x += 4 注意： 如果运算符得到一个值，其类型与左侧操作数类型不同，，就会发生强制类型转换，如 int x = 2 ; x += 3.14 ; 这相当于 x = （int）（x + 3.14） 自增自减运算符java中借鉴了C和C++的做法，提供了自增自减运算符：n + + 将当前值加1 这种运算符有两种形式：运算符作为前缀和运算符作为后缀。例： 1234int m = 7 ;int n = 7 ;int a = 2 * ++n; //a=16,m=8int b = 2 * n++; //b=14,n=8 前缀形式先完成加1，后缀形式会使用原来的值，再加1。 不建议在表达式中使用++,因为这样的代码很容易让人困惑，而且会带来烦人的bug。 &amp;&amp;和&amp; 与 ||和|&amp;&amp;表示逻辑“与”，||表示逻辑“或”。 这两个运算符是按照“短路”方式来求值的：如果第一个操作数已经能够确定表达式的值，第二个操作数就不会计算了。如：12exp1 &amp;&amp; exp2 ,当exp1为flase时，那么exp2就不会执行了。exp1 || exp2 ,当exp1为true时，那么exp2就不会执行了。 &amp;和| 运算符不采用“短路”方式求值，所以不论第一个操作数是否确定整个表达式的值，两个操作数都会被计算。 字符串 检测是否相等 一定要用equals()函数，它是判断两个字符串内容是否相等，而 == 是判断两个字符串是否在同一个位置上。如果 == 相等，那么equals一定相等，反之不然。 空串和Null “”是一个Java对象，有自己的串长度（0）和内容（空），当为Null时，表示目前没有任何对象与该变量关联。 检查一个字符串既不是null也不是空串：1if(str != null &amp;&amp; str.length() != 0) 要先检查不为null，因为为null时无法调用length()函数。 多重选择：switch12345678switch(x)&#123; case x1 : *** break; case x2 : *** break;&#125; 其中x可以为char,byte,short,int类型，到Java SE 7开始，可以是String类型的。 一般不建议使用switch语句，因为break语句的忘记容易导致问题。 命令行参数学习Java你一定知道下面代码： 123456public class Massage&#123; public static void main(String[] args)&#123; System.out.println(args[0]); System.out.println(args[1]); &#125;&#125; 当你在命令行变异运行这个类时：java Massage -hello world 打印结果： 12helloworld 第四章 对象与类类之间的关系 依赖（uses-a） A类方法操纵B类对象，叫做一个类依赖另一个类。 聚合（has-a） A类的对象包含B类的对象。 继承（is-a） A类继承B类。 我们应该尽量减少相互依赖的类存在，如果A类不知道B类，就不会关系B类的变化，这样B类无论怎么变化都不会导致A的bug，软件工程上叫做：让类之间的耦合度最小。 Java 8中新增LocalDate类Date是一个用来表示时间点的Date类，LocalDate用来表示大家熟悉的日历表示法。 Date类所提供的日期处理并没有太大的用途。 1.Date和SimpleDateFormatter都不是线程安全的。2.Date对日期的计算方式繁琐，月份从0开始。 创建一个对象可以通过以下几个方式： 123LocalDate local1 = LocalDate.now();LocalDate local2 = LocalDate.of(2017,10,30); LocalDate并不包含时间，你可以通过下面获取年月日： 123int year = local2.getYear();int month = local2.getMonthValue();int day = local2.getDayOfMonth(); 当然LocalDate也提供了日期的增减： 12local2.pulsDays(100);local2.minusDays(100); 更多方法查看API，这里不做详细表述。 final实例域将实例域定义为final，构建对象时必须初始化这个实例域，后面的操作中不能够再对它进行修改。如： 1234public class Employee&#123; private final String name; ……&#125; 这个name属性没有setName方法。final修饰符大都应用于基本数据类型或不可变的类或对象。如果类中每个方法都不会改变其对象，那么这个类就是不可变类，如String类。 对于可变的类使用final修饰，会对别人造成混乱。如： 1private final StringBuilder sb; 在Employee构造方法中进行初始化 123public Employee()&#123; sb = new StringBuilder();&#125; final关键词只是表示存储在sb变量中的对象应用不会再指向其他StringBuilder对象，不过这个对象可以更改： 123public void giveGoldStar()&#123; sb.append( LocalDate.now() + &quot;: Gold star!&quot;);&#125; 静态域 static12345public class Employee&#123; private static int sid = 1001; private int id ; ……&#125; static 修饰的常量，是面向类的，即无论存在多少Employee对象，sid只存在一个，所有对象将共享一个sid，但id却和对象同存在，多少个对象就有多少个id。（static 修饰后，它属于类，而不属于任何对象） 静态工厂方法类似LocalDate.now和LocalDate.of都是使用静态工厂方法来构造对象。 12345NumberFormat currenyFormatter = NumberFormat.getCurrencyInstance();NumberFormat percentFormatter = NumberFormat.getPercentInstance();double x = 0.1;System.out.println(currenyFormatter.format(x)); //输出 $0.10System.out.println(percentFormatter.format(x)); //输出 10% 为什么不利用构造方法来完成这些操作呢？原因： 无法命名构造器，这里希望得到的货币实例和百分比实例采用不同的名字。 当使用构造器时，无法改变所构造的对象类型，而Factory方法将返回一个DecimalFormat类对象，这是NumberFormat的子类。 方法参数方法参数共有两种类型： 基本数据类型 对象类型 一个方法不可能修改一个基本数据类型的参数，如： 12double x = 10;harry.raiseSalary(x); 中不论加薪方法具体怎么实现，但x值始终不变。 对象作为参数其实是对象引用的拷贝，他们指向同一个对象。 12345678910public void swap(Employee x,Employee y)&#123; Employee temp = x; x = y; y = temp;&#125; Employee a = new Employee(&quot;zhang&quot;); Employee b = new Employee(&quot;wang&quot;); swap(a,b); //现在x指向wang,y指向zhang System.out.println(a.toString()+&quot;--&quot;+b.toString()); 最后你会发现a依然是zhang,b依然是wang,因为形参x，y在执行完后被丢弃了，原来的a，b依然指向之前的的对象。 总结： java对对象采用的不是引用调用，实际上，对象引用是按值传递的。 一个方法不能修改一个基本数据类型（数值型和布尔型） 一个方法可以改变一个对象的状态（属性……） 一个方法不能让一个对象参数引用新的对象 无參构造函数当一个类没有提供构造函数时，系统会为这个类提供一个默认的无參构造函数，但当你提供了有参的构造函数时，系统是不会提供无參构造函数的，所以当你要调用无參构造函数时，主动提供无參构造函数或不提供任何构造函数。 类设计技巧 一定保证数据的私有性 一定对数据初始化 不要在类中使用过多的基本类型 将职责过多的类进行分解 类名和方法名要能体现他们的职责 优先使用不可变类 类不可变，就可以安全地在多个线程间共享其对象。 第五章 继承父类和子类 将通用方法放在父类中，而将具有特殊用途的方法放在子类中。 关键字this的两种用法：一是引用本类成员变量，二是调用本类其他构造函数。 关键字super两种用法：一是应用父类成员变量，二是调用父类构造函数。不过两者调用构造函数时，调用语句必须放在构造函数第一行。","link":"/2017/10/19/【读】Java核心技术卷1/"},{"title":"二、八、十、十六进制转换（图解篇）","text":"Java语法中是支持位运算的，在进行位运算前，我们最好对各个进制及其转换都了解下，这篇文章讲解的很是详细。 背景（Contexts） 之前使用SQL把十进制的整数转换为三十六进制，SQL代码请参考：SQL Server 进制转换函数，其实它是基于二、八、十、十六进制转换的计算公式的，进制之间的转换是很基础的知识，但是我发现网络上没有一篇能把它说的清晰、简单、易懂的文章，所以我才写这篇文章的念头，希望能让你再也不用担心、害怕进制之间的转换了。 下面是二、八、十、十六进制之间关系的结构图： 下文会分4个部分对这个图进行分解，针对每个部分会以图文的形式进行讲解： （二、八、十六进制） → （十进制）； （十进制） → （二、八、十六进制）； （二进制） ↔ （八、十六进制）； （八进制） ↔ （十六进制）； 进制转换算法（Convert） 在数字后面加上不同的字母来表示不同的进位制。B（Binary)表示二进制，O（Octal）表示八进制，D（Decimal）或不加表示十进制，H（Hexadecimal）表示十六进制。例如：(101011)B=(53)O=(43)D=(2B)H (一) （二、八、十六进制） → （十进制） 二进制 → 十进制 方法：二进制数从低位到高位（即从右往左）计算，第0位的权值是2的0次方，第1位的权值是2的1次方，第2位的权值是2的2次方，依次递增下去，把最后的结果相加的值就是十进制的值了。 例：将二进制的(101011)B转换为十进制的步骤如下： 第0位 1 x 2^0 = 1； 第1位 1 x 2^1 = 2； 第2位 0 x 2^2 = 0； 第3位 1 x 2^3 = 8； 第4位 0 x 2^4 = 0； 第5位 1 x 2^5 = 32； 读数，把结果值相加，1+2+0+8+0+32=43，即(101011)B=(43)D。 八进制 → 十进制 方法：八进制数从低位到高位（即从右往左）计算，第0位的权值是8的0次方，第1位的权值是8的1次方，第2位的权值是8的2次方，依次递增下去，把最后的结果相加的值就是十进制的值了。 八进制就是逢8进1，八进制数采用 0～7这八数来表达一个数。 例：将八进制的(53)O转换为十进制的步骤如下： 第0位 3 x 8^0 = 3； 第1位 5 x 8^1 = 40； 读数，把结果值相加，3+40=43，即(53)O=(43)D。 十六进制 → 十进制 方法：十六进制数从低位到高位（即从右往左）计算，第0位的权值是16的0次方，第1位的权值是16的1次方，第2位的权值是16的2次方，依次递增下去，把最后的结果相加的值就是十进制的值了。 十六进制就是逢16进1，十六进制的16个数为0123456789ABCDEF。 例：将十六进制的(2B)H转换为十进制的步骤如下： 第0位 B x 16^0 = 11； 第1位 2 x 16^1 = 32； 读数，把结果值相加，11+32=43，即(2B)H=(43)D。 (二) （十进制） → （二、八、十六进制） 十进制 → 二进制 方法：除2取余法，即每次将整数部分除以2，余数为该位权上的数，而商继续除以2，余数又为上一个位权上的数，这个步骤一直持续下去，直到商为0为止，最后读数时候，从最后一个余数读起，一直到最前面的一个余数。 例：将十进制的(43)D转换为二进制的步骤如下： 将商43除以2，商21余数为1； 将商21除以2，商10余数为1； 将商10除以2，商5余数为0； 将商5除以2，商2余数为1； 将商2除以2，商1余数为0； 将商1除以2，商0余数为1； 读数，因为最后一位是经过多次除以2才得到的，因此它是最高位，读数字从最后的余数向前读，101011，即(43)D=(101011)B。 十进制 → 八进制 方法1：除8取余法，即每次将整数部分除以8，余数为该位权上的数，而商继续除以8，余数又为上一个位权上的数，这个步骤一直持续下去，直到商为0为止，最后读数时候，从最后一个余数起，一直到最前面的一个余数。 例：将十进制的(796)D转换为八进制的步骤如下： 将商796除以8，商99余数为4； 将商99除以8，商12余数为3； 将商12除以8，商1余数为4； 将商1除以8，商0余数为1； 读数，因为最后一位是经过多次除以8才得到的，因此它是最高位，读数字从最后的余数向前读，1434，即(796)D=(1434)O。 方法2：使用间接法，先将十进制转换成二进制，然后将二进制又转换成八进制； 十进制 → 十六进制 方法1：除16取余法，即每次将整数部分除以16，余数为该位权上的数，而商继续除以16，余数又为上一个位权上的数，这个步骤一直持续下去，直到商为0为止，最后读数时候，从最后一个余数起，一直到最前面的一个余数。 例：将十进制的(796)D转换为十六进制的步骤如下： 将商796除以16，商49余数为12，对应十六进制的C； 将商49除以16，商3余数为1； 将商3除以16，商0余数为3； 读数，因为最后一位是经过多次除以16才得到的，因此它是最高位，读数字从最后的余数向前读，31C，即(796)D=(31C)H。 方法2：使用间接法，先将十进制转换成二进制，然后将二进制又转换成十六进制； (三) （二进制） ↔ （八、十六进制） 二进制 → 八进制 方法：取三合一法，即从二进制的小数点为分界点，向左（向右）每三位取成一位，接着将这三位二进制按权相加，然后，按顺序进行排列，小数点的位置不变，得到的数字就是我们所求的八进制数。如果向左（向右）取三位后，取到最高（最低）位时候，如果无法凑足三位，可以在小数点最左边（最右边），即整数的最高位（最低位）添0，凑足三位。 例：将二进制的(11010111.0100111)B转换为八进制的步骤如下： 小数点前111 = 7； 010 = 2； 11补全为011，011 = 3； 小数点后010 = 2； 011 = 3； 1补全为100，100 = 4； 读数，读数从高位到低位，即(11010111.0100111)B=(327.234)O。 二进制与八进制编码对应表： 二进制 八进制 000 0 001 1 010 2 011 3 100 4 101 5 110 6 111 7 八进制 → 二进制 方法：取一分三法，即将一位八进制数分解成三位二进制数，用三位二进制按权相加去凑这位八进制数，小数点位置照旧。 例：将八进制的(327)O转换为二进制的步骤如下： 3 = 011； 2 = 010； 7 = 111； 读数，读数从高位到低位，011010111，即(327)O=(11010111)B。 二进制 → 十六进制 方法：取四合一法，即从二进制的小数点为分界点，向左（向右）每四位取成一位，接着将这四位二进制按权相加，然后，按顺序进行排列，小数点的位置不变，得到的数字就是我们所求的十六进制数。如果向左（向右）取四位后，取到最高（最低）位时候，如果无法凑足四位，可以在小数点最左边（最右边），即整数的最高位（最低位）添0，凑足四位。 例：将二进制的(11010111)B转换为十六进制的步骤如下： 0111 = 7； 1101 = D； 读数，读数从高位到低位，即(11010111)B=(D7)H。 十六进制 → 二进制 方法：取一分四法，即将一位十六进制数分解成四位二进制数，用四位二进制按权相加去凑这位十六进制数，小数点位置照旧。 例：将十六进制的(D7)H转换为二进制的步骤如下： D = 1101； 7 = 0111； 读数，读数从高位到低位，即(D7)H=(11010111)B。 (四) （八进制） ↔ （十六进制） 八进制 → 十六进制 方法：将八进制转换为二进制，然后再将二进制转换为十六进制，小数点位置不变。 例：将八进制的(327)O转换为十六进制的步骤如下： 3 = 011； 2 = 010； 7 = 111； 0111 = 7； 1101 = D； 读数，读数从高位到低位，D7，即(327)O=(D7)H。 十六进制 → 八进制 方法：将十六进制转换为二进制，然后再将二进制转换为八进制，小数点位置不变。 例：将十六进制的(D7)H转换为八进制的步骤如下： 7 = 0111； D = 1101； 0111 = 7； 010 = 2； 011 = 3； 读数，读数从高位到低位，327，即(D7)H=(327)O。 扩展阅读 1. 包含小数的进制换算： (ABC.8C)H=10x16^2+11x16^1+12x16^0+8x16^-1+12x16^-2 =2560+176+12+0.5+0.046875 =(2748.546875)D 2. 负次幂的计算： 2^-5=2^(0-5)=2^0/2^5=1/2^5 同底数幂相除，底数不变，指数相减，反过来 我们需要了解一个数学关系，即23=8，24=16，而八进制和十六进制是用这关系衍生而来的，即用三位二进制表示一位八进制，用四位二进制表示一位十六进制数。接着，记住4个数字8、4、2、1（23=8、22=4、21=2、20=1）。 参考文献（References）二进制、八进制、十进制、十六进制之间转换 二进制如何转换成八进制","link":"/2018/07/14/二、八、十、十六进制转换（图解篇)/"},{"title":"设计模式-单例模式","text":"单例模式是最常见的设计模式之一，虽然看似简单，但要真正用好并不是那么容易。 介绍定义保证一个类仅有一个实例，并提供一个访问它的全局访问点。 （Ensure a class only has one instance,and provide a global point of access to it.） 使用场景 需要生成唯一序列的环境 需要频繁实例化然后销毁的对象。 创建对象时耗时过多或者耗资源过多，但又经常用到的对象。 方便资源相互通信的环境 使用实例在Java API中Runtime就是单例的一个实际应用。 1234567891011public class Runtime &#123; private static Runtime currentRuntime = new Runtime(); public static Runtime getRuntime() &#123; return currentRuntime; &#125; private Runtime() &#123;&#125; ……&#125; 几种写法饿汉式饿汉式：将类的实例化在类被加载时就开始（它很饿，想马上得到这块大饼）。 饿汉式本身是线程安全的，实现起来也比较简单。这种方式是拿空间换时间的做法。 123456789101112131415161718192021public class EagerSingleton &#123; /** * 定义时即初始化，保证了线程安全 */ private static EagerSingleton instance = new EagerSingleton(); /** * 私有构造器，防止被外部实例化 */ private EagerSingleton() &#123;&#125; /** * 静态方法获取实例 * * @return */ public static EagerSingleton getInstance() &#123; return instance; &#125;&#125; 懒汉式懒汉式：将类的实例化延迟到子类或方法中（它很懒，不想一开始就去创建实例）。 线程不安全这种方式虽然最为简单，但也最不推荐的一种写法。因为在多线程环境下，会创建多个实例。 123456789101112131415161718192021public class LazySingleton1 &#123; private static LazySingleton1 instance = null; /** * 私有构造器，防止被外部实例化 */ private LazySingleton1() &#123;&#125; /** * 静态方法创建实例 * * @return */ public static LazySingleton1 getInstance() &#123; if (instance == null) &#123; return new LazySingleton1(); &#125; return instance; &#125;&#125; 线程安全我们现在根据上面的单例进行更改，使之多线程下也只会创建一个实例。怎么做呢？我们把获取实例的方法getInstance() 设置为同步的（synchronized）。 123456789101112131415161718192021public class LazySingleton2 &#123; private static LazySingleton2 instance = null; /** * 私有构造器，防止被外部实例化 */ private LazySingleton2() &#123;&#125; /** * 静态方法创建实例 * * @return */ public static synchronized LazySingleton2 getInstance() &#123; if (instance == null) &#123; return new LazySingleton2(); &#125; return instance; &#125;&#125; 这样看似不错，但加入锁后会使方法性能下降，看看能不能再优化一些。我们发现其实我们不必在进去入方法就加锁，我们只要在创建实例时加锁即可。 1234567891011121314151617181920212223public class LazySingleton3 &#123; private static LazySingleton3 instance = null; /** * 私有构造器，防止被外部实例化 */ private LazySingleton3() &#123;&#125; /** * 静态方法创建实例 * * @return */ public static LazySingleton3 getInstance() &#123; if (instance == null) &#123; synchronized (instance)&#123; return new LazySingleton3(); &#125; &#125; return instance; &#125;&#125; 双重校验锁（Double Checked Locking）上面的方式仍然会存在问题，如果多次调用同时进入到了if (instance == null)语句，那么就会创建多个实例。 1234567891011121314151617181920public class Singleton &#123; private static volatile Singleton instance; /** * 私有构造器，防止被外部实例化 */ private Singleton() &#123;&#125; public static Singleton getSingleton() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 静态内部类（static nested class）这种方式也可以延迟加载并能保证初始化时只有一个线程。 123456789101112public class Singleton &#123; private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; private Singleton() &#123;&#125; public static final Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125;&#125; 枚举单例枚举单例是一种比较新的实现单例的方式，也是比较推荐的写法。因为：1. 枚举单例写法简单 2. 线程安全 123456789101112public enum Singleton &#123; INSTANCE; /** * 单例中的方法 */ public void method() &#123; System.out.println(\"单例枚举方法\"); &#125; public static void main(String args[]) &#123; Singleton.INSTANCE.method(); &#125;&#125; 总结 方式 线程 初始化 难度 饿汉式 安全 立即创建 容易 懒汉式 安全/不安全 懒加载 容易 静态内部类 安全 懒加载 一般 双重锁 安全 懒加载 复杂 枚举 安全 立即创建 容易 综上所述，我认为优先使用枚举方式，静态内部类和饿汉式，当然还是得根据具体情况而定。","link":"/2018/08/14/设计模式-单例模式/"},{"title":"聊聊你应该知道的Java8","text":"Java8可以是近年改动比较大的一版，对于性能，易用性上都有提升，学会Java8将大大提高我们的效率。你要知道Java8发布与2014年，而今Java11也已经发布了，你还在停留在Java7吗？ 新特性Lambda表达式定义“Lambda 表达式”(lambda expression)是一个匿名函数，Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象(lambda abstraction)，是一个匿名函数，即没有函数名的函数。 语法Lambda的组成由下图可知：箭头操作符将Lambda表达式分为左右两侧，左侧是参数列表，右侧是所有执行的代码。 针对左右两侧还有几种语法的变形： 参数 参数类型可省略 仅一个参数，小括号可省略 (a,b) -&gt; {}a -&gt; {} 执行主体 多条语句，必须有大括号{ } 仅一条语句，return / { }可省略 (a,b) -&gt; { a= a + b; return a; }a -&gt; a++ Stream API什么是Stream ？新日期 API为什么设计新的日期时间API ？接口默认，静态方法Optional组合式异步编程总结","link":"/2018/08/25/聊聊你应该知道的Java8/"},{"title":"设计模式-建造者模式","text":"软件是现实世界的抽象，现实中制造一个机器人是一个非常复杂的过程，同样在软件中也是，但我们仍然需要创建这个复杂的机器人对象，但怎么能让我们简单的创建出这个复杂的对象呢？ 定义建造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 角色 Builder：抽象建造者定义了产品的创建及返回方法。 ConcreteBuilder：具体建造者具体如何创建产品及返回产品 Director：指挥者指挥建造者建造产品的过程 Product：产品角色要建造的复杂产品，包含多个组成部分 示例复杂产品 123456789101112131415161718192021222324/** * @author: flyhero * @date: 2018-08-29 下午7:05 */public class Robot &#123; /** * 骨架 */ private String skeleton; /** * 主板 */ private String mainboard; /** * 电池 */ private String battery; //getter and setter …… //toString&#125; 抽象建造者 12345678910111213141516171819202122232425262728/** * @author: flyhero * @date: 2018-08-29 下午7:14 */public interface Builder &#123; /** * 构建骨架 */ void buildSkeleton(); /** * 构建主板 */ void buildMailboard(); /** * 构建电池 */ void buildBattery(); /** * 组装结果 * * @return */ Robot getResult();&#125; 具体建造者 12345678910111213141516171819202122232425262728/** * @author: flyhero * @date: 2018-08-29 下午7:22 */public class RobotBuilder implements Builder&#123; private Robot robot = new Robot(); @Override public void buildSkeleton() &#123; robot.setSkeleton(\"构建机器骨架\"); &#125; @Override public void buildMailboard() &#123; robot.setMainboard(\"构建主板\"); &#125; @Override public void buildBattery() &#123; robot.setBattery(\"构建电池\"); &#125; @Override public Robot getResult() &#123; return this.robot; &#125;&#125; 指挥者 123456789101112131415161718192021222324252627282930public class Director &#123; /** * 生成器 */ private Builder builder; public Director(Builder builder) &#123; this.builder = builder; &#125; /** * 生产机器人 * * @return */ public Robot build() &#123; builder.buildSkeleton(); builder.buildMailboard(); builder.buildBattery(); return builder.getResult(); &#125;/* public static void main(String[] args) &#123; Builder builder = new RobotBuilder(); Director director = new Director(builder); Robot robot = director.build(); System.out.println(robot.toString()); &#125;*/&#125; UML 优点 客户端不需要知道产品的内部细节，将产品与产品的创建过程进行解耦，使得同样的创建过程可以创建不同的产品对象。 每个具体建造者相对独立，可以很方便的增加新的建造者。 缺点 建造者模式所创建的产品一般具有较多的共同点，其组成部分也比较相似，如果产品之间差异性较大，就不太合适了。","link":"/2018/08/30/设计模式-建造者模式/"},{"title":"设计模式-开篇","text":"设计模式是针对某一类问题的最优化解决方案，是从许多优秀的软件中总结出来的。 学习设计模式应该是我们Java开发必须要的，本篇主要对设计模式整体有个认识。 模式创建型模式创建型模式涉及对象的实例化，特点是不让用户依赖于对象的创建或排列方式，避免用户直接使用new创建对象。 主要有一下5种： 工厂方法模式、抽象工厂方法模式、生成器模式、原型模式、单例模式 行为型模式行为模式涉及怎么合理的设计对象在之间的交互通信、以及怎么合理的为对象分配指责、让设计富有弹性、易于维护，易于复用。 主要有一下11种： 责任链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、模板方法模式、访问者模式。 结构型模式结构型模式涉及如何组合类和对象以形成更大的结构，和类有关的结构型模式涉及如何合理使用继承机制；和对象有关的结构型模式涉及如何合理的使用对象组合机制。 结构型模式有以下7个： 适配器模式、组合模式、代理模式、享元模式、外观模式、桥接模式、装饰模式。 原则 单一职责原则 (Single Responsibility Principle）：一个类负责一项职责。 里氏替换原则 (Liskov Substitution Principle）：只要父类能出现的地方子类就可以出现，替换为子类也不会产生任何错误和异常，但是反过来却不行，有子类的地方父类未必能适应。 依赖倒置原则 (Dependence Inversion Principle）：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。即针对接口编程，不要针对实现编程。 接口隔离原则 (Interface Segregation Principle）：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。 迪米特法则 (Low Of Demeter）：低耦合，高内聚. 开闭原则 (Open Close Principle）：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。 组合/聚合复用原则(Composition/Aggregation Reuse Principle(carp) ）：尽量使用组合和聚合少使用继承的关系来达到复用的原则。 总结最后通过一张图来整体认识一下：","link":"/2018/07/26/设计模式-开篇/"},{"title":"设计模式-工厂方法模式","text":"工厂方法模式是创建型模式之一。它结构清晰简单，是常用的一种模式，也比较适合我们入门学习。 简单工厂（Simple Factory Pattern）简单工厂模式又叫静态工厂方法。虽然它并不属于23种GOF设计模式之一。但是他是抽象工厂模式，工厂方法模式的基础，并且也有广泛的应用。 先来看看是怎么实现简单工厂的，以现在性价比较好的手机厂商小米和魅族为例。 两家都生产手机这个产品，所以可以抽象出来一个产品，两家有各自的具体产品。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * @author: flyhero * @date: 2018-07-28 上午10:20 */public abstract class Phone &#123; public String name; public Double price; /** * 输出品牌 */ public abstract void brand(); /** * 运行手机 */ public abstract void run();&#125;//小米手机public class XiaoMiPhone extends Phone &#123; public XiaoMiPhone() &#123; name = \"小米\"; price = 1599d; &#125; @Override public void brand() &#123; System.out.println(\"品牌：\" + name + \" 价格：\" + price); &#125; @Override public void run() &#123; System.out.println(\"开启小米手机\"); &#125;&#125;//魅族手机public class MeizuPhone extends Phone &#123; public MeizuPhone() &#123; name = \"魅族\"; price = 1999d; &#125; @Override public void brand() &#123; System.out.println(\"品牌：\" + name + \" 价格：\" + price); &#125; @Override public void run() &#123; System.out.println(\"开启魅族手机\"); &#125;&#125; 我要有一座工厂，可以生产不同的手机。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class SimplePhoneFactory &#123; /** * 根据不同参数生产不同实例 * * @param brand * @return */ public Phone produce(String brand) &#123; Phone phone = null; switch (brand) &#123; case \"meizu\": phone = new MeizuPhone(); break; case \"xiaomi\": phone = new XiaoMiPhone(); break; default: break; &#125; return phone; &#125; /** * 通过反射机制生产 * * @param clazz * @return */ public Phone produceX(Class clazz) &#123; Phone phone = null; try &#123; phone = (Phone) clazz.newInstance(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; return phone; &#125;&#125; 现在我新建一个工厂，然后告诉工厂我想要生产小米或魅族手机就可以了。 123456789public class Client &#123; public static void main(String[] args) &#123; SimplePhoneFactory simplePhoneFactory = new SimplePhoneFactory(); simplePhoneFactory.produce(\"xiaomi\").brand(); simplePhoneFactory.produce(\"meizu\").brand(); simplePhoneFactory.produceX(XiaoMiPhone.class).brand(); simplePhoneFactory.produceX(MeizuPhone.class).brand(); &#125;&#125; UML 为什么使用？我们一直强调要面向接口编程，尽量不要依赖于具体的类。这里我们抽象出了产品类，然后通过一个工厂类，输入不同的参数可以创建不同的产品，这大大解耦了客户端依赖过多的类。 有什么不好的地方？ 增加产品，需要修改工厂类，不符合开闭原则 工厂类集中了所有实例的创建逻辑，违反了高内聚责任分配原则 工厂方法模式 定义：一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。 何时使用 用户需要一个类的子类的实例，但不希望与该类的子类形成耦合 用户需要一个类的子类的实例，但用户不知道该类有哪些子类可用 优点 使用工厂方法可以让用户的代码和某个特定类的子类的代码解耦 工厂方法使用户不必知道它所使用的对象是怎样被创建的，只需知道该对象有哪些方法即可。 如何实现 抽象一个产品，同简单工厂第一步。 抽象出一个工厂类和n个具体工厂 1234567891011121314151617181920212223public interface IFactory &#123; /** * 生产实例 * * @return */ Phone produce();&#125;//魅族工厂public class MeizuFactory implements IFactory&#123; @Override public Phone produce() &#123; return new MeizuPhone(); &#125;&#125;//小米工厂public class XiaoMiFactory implements IFactory &#123; @Override public Phone produce() &#123; return new XiaoMiPhone(); &#125;&#125; 现在我要生产魅族手机就新建魅族工厂，小米就新建小米工厂。 123456789public class Client &#123; public static void main(String[] args) &#123; IFactory meizu = new MeizuFactory(); meizu.produce().brand(); IFactory xiaomi = new XiaoMiFactory(); xiaomi.produce().brand(); &#125;&#125; UML 抽象工厂模式 定义：提供一个创建一系列或相互依赖对象的接口，而无须指定他们的具体的类。 现在每个工厂只生产了手机，但现在想要再生产耳机呢？于是我又抽象出来了“抽象类耳机”。 12345678910111213141516171819202122public abstract class Headset &#123; public String name; public Double price; /** * 播放 */ public abstract void play(); &#125; public class XiaomiHeadset extends Headset &#123; @Override public void play() &#123; System.out.println(\"小米耳机播放音乐\"); &#125;&#125;public class MeizuHeadset extends Headset &#123; @Override public void play() &#123; System.out.println(\"魅族耳机播放音乐\"); &#125;&#125; 于是我在抽象工厂类中扩展类一个生产耳机的方法： 1234567891011121314151617181920212223242526272829303132333435public interface IFactory &#123; /** * 生产实例 * * @return */ Phone produce(); /** * 生产耳机 * * @return */ Headset produceHeadset();&#125;public class MeizuFactory implements IFactory&#123; @Override public Phone produce() &#123; return new MeizuPhone(); &#125; @Override public Headset produceHeadset() &#123; return new MeizuHeadset(); &#125;&#125;public class XiaoMiFactory implements IFactory &#123; @Override public Phone produce() &#123; return new XiaoMiPhone(); &#125; @Override public Headset produceHeadset() &#123; return new XiaoMiHeadset(); &#125;&#125; 现在魅族或小米无论想要生产手机或耳机，就可以新建自己的工厂，然后调用对应的生产方法就可以了。 1234567891011public class Client &#123; public static void main(String[] args) &#123; IAbstractFactory meizu = new MeizuFactory(); meizu.produceHeadset().play(); meizu.producePhone().run(); IAbstractFactory xiaomi = new XiaomiFactory(); xiaomi.produceHeadset().play(); xiaomi.producePhone().run(); &#125;&#125; UML 总结真实的忠告：看三遍不如实践一遍，看三遍加实践效果更佳。 结合UML图就可以知道三者的区别。 简单工厂模式 一个抽象的产品，n个具体的产品 没有抽象工厂，1个具体工厂 根据输入的参数不同，创建不同的具体产品 工厂方法模式 一个抽象的产品，n个具体的产品 一个抽象的工厂，n个具体的工厂 每个工厂只生产一个产品 抽象工厂模式 一个抽象的产品，n个具体的产品 一个抽象的工厂，n个具体的工厂 每个工厂只生产n个产品","link":"/2018/07/28/设计模式-工厂方法模式/"},{"title":"进阶必会的Java反射","text":"学习反射时是不是感到枯燥乏味？因为干涩涩的知识谁都会这样，除非有动力，那么什么动力会让你去学习反射呢？我来说一个我的动力：我要阅读优秀的框架源码。虽然反射只是阅读源码的知识点之一，但确实很重要的一点，比如：Spring AOP、Mybatis都会运用到。 什么是反射？首先看下官方定义： Reflection enables Java code to discover information about the fields, methods and constructors of loaded classes, and to use reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions.The API accommodates applications that need access to either the public members of a target object (based on its runtime class) or the members declared by a given class. It also allows programs to suppress default reflective access control. 反射 (Reflection) 是 Java 的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。 以上归纳起来就是： 在运行时判断任意一个对象所属的类； 在运行时构造任意一个类的对象； 在运行时判断任意一个类的所有成员变量和方法； 在运行时调用任意一个对象的方法。 反射操作常用的反射相关类常用的类除Class都在java.lang.reflect包下： Class Constructor Method Field Class类怎么理解Class类呢？首先，Class类和class定义类的关键字是不一样的。其实Class类和其他普通类同样是一个实实在在的类，只不过它所表示的是在运行时各个类的类型信息，所以任何类都可以得到一个Class类（相同类的不对对象得到的是同一个Class对象）。 getClass本地方法Object类拥有一个本地方法getClass()方法，通过它可直接获取一个Class类对象。1Class clazz = object.getClass(); Class.forName 方法有一个行代码估计你闭上眼都能想到这段加载数据库驱动的代码，它就是用到了反射。1Class clazz = Class.forName(\"com.mysql.jdbc.Driver\"); Class字面常量这种方式最为方便，无论基本类型还是引用类型都可以通过下面类获得，但前提是在编译时就知道所要获取的类名称并且类存在。1Class clazz = int.class; 三种对比 第一种需要持有该类的实例对象 第二三种不需要持有实例对象 第三种效率更高也更方便，不需要调用任何方法。 Constructor构造器类获取Constructor类的目的就是创建对象，下面我们看如何创建类的对象。1234567891011121314151617181920212223242526272829303132333435363738/** * @author: flyhero * @date: 2018-10-29 6:50 PM */ public class User &#123; private int age = 20; public String name = \"wang\"; public static final String say = \"hello , everybody\"; public User() &#123; &#125; public User(int age, String name) &#123; this.age = age; this.name = name; &#125; //getter and setter public static void main(String[] args) &#123; Class clazz = User.class; try &#123; //方式一 User user = (User) clazz.newInstance(); System.out.println(user.getName()); //方式二 Constructor constructor = clazz.getConstructor(int.class, String.class); User user1 = (User) constructor.newInstance(10, \"flyhero\"); System.out.println(user1.getName()); &#125; catch (InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 方式一User user = (User) clazz.newInstance();Class类提供类一个创建实例的方法，但这是有条件的，首先该类要有无參构造函数，否则会抛出一样。 方式二 12Constructor constructor = clazz.getConstructor(int.class, String.class); User user1 = (User) constructor.newInstance(10, \"flyhero\"); 这是获取类的指定有参构造器，然后调用newInstance依次传入指定的参数。 Method类12345678910try &#123; User user = (User) clazz.newInstance(); Method[] publicMethods = clazz.getMethods(); Method publicMethod = clazz.getMethod(\"setAge\", int.class); publicMethod.invoke(user,22); Method[] allMethods = clazz.getDeclaredMethods(); Method allMethod = clazz.getDeclaredMethod(\"setName\", String.class);&#125; catch (NoSuchMethodException | IllegalAccessException |InstantiationException |InvocationTargetException e) &#123; e.printStackTrace();&#125; getMethods方法我们主要使用上面这四个方法来获取Method对象,方法名称中含有Declared的，表示可以获取所有方法，包括私有方法。 invoke方法publicMethod.invoke(user,22)Method通过invoke方法来执行本方法，不过要注意它的参数，它需要本方法所在的类的实例，以及本方法所需要的参数。 Field类12345678910try &#123; User user = (User) clazz.newInstance(); Field field = clazz.getField(\"name\"); Field[] fields = clazz.getFields(); field.setAccessible(true); field.set(user,\"flyhero\"); Class&lt;?&gt; fieldClazz = field.getType(); &#125; catch (NoSuchFieldException | IllegalAccessException |InstantiationException e) &#123; e.printStackTrace(); &#125; getFields方法方法名称中含有Declared的，表示可以获取所有属性，包括私有属性。 set方法如果需要设置私有属性的值，则需要先设置属性的field.setAccessible(true);然后field.set(user,&quot;flyhero&quot;);需要本属性的类对象，和具体值作为参数。","link":"/2018/10/15/进阶必会的Java反射/"},{"title":"高效工具集合","text":"不可否认，顺手的工具能帮助我们提高工作的效率，这里我将列出我所用到过的高效工具。 录屏Gif软件：ScreenToGif 推荐：ScreenToGif正如其名，是一款通过录屏来制作Gif动画的软件，虽然文件大小只有几兆，却有非常强大的功能，界面优美，而且完全免费，是我目前用过最好的，强烈推荐！ 接口调试工具：Postman 在我们平时开发中，特别是需要与接口打交道时，无论是写接口还是用接口，拿到接口后肯定都得提前测试一下，这样的话就非常需要有一个比较给力的Http请求模拟工具，现在流行的这种工具也挺多的，但Postman是我最青睐的一个。 JSON格式化工具：桌面版CyJsonView 2.3.1 浏览器版JSONView 桌面版CyJsonView作者藏言基于Java开发的开源软件，需要有Java开发环境，界面简洁明了，功能也非常全。 浏览器版JSONView,是浏览器中格式化的插件，平时接口请求直接返回格式化后的，支持收缩，展开，一目了然。 远程控制软件：TeamViewer 相对于其它远程控制，视频会议等软件（如：QQ远程），TeamViewer无论是视频清晰度，流畅度都要优于其它，使用也比较简单。 截屏软件：PicPick PicPick 是一款优秀的免费屏幕截图工具，汇集屏幕截取、取色器、调色板、放大镜、标尺、量角器、坐标轴、白板等功能于一身。支持的屏幕截图模式包括：全屏、活动窗口、滚动窗口、矩形区域、固定区域、手绘区域、重复上次截取等，这应该满足绝大部分需求了。 远程终端模拟软件：Xshell and Xftp 免费软件 Xshell 和 Xftp 都是 NetSarang 出品的优秀网络管理、安全传输工具。Xshell 是一个免费的安全终端仿真器，可以作为 SSH、TELNET 或 RLOGIN 的终端模拟，能够从 Windows 平台安全连接 Linux 服务器，Xftp 则是安全传输客户端，支持 FTP 和 SFTP 协议，两者都支持标签化的会话窗口。如果你的项目部署到Liunx下面，这样的工具你少不了的。 卸载工具：Uninstall Tool 你是否遇到过这样的问题呢？卸载某个软件后，重新安装或者安装同公司不同软件，发现无法安装问题，这可能就是注册表未删除的问题，而且还留有卸载残余文件。那么现在Uninstall Tool可以帮你解决这些问题，它很小，而且表现不错。 UML画图工具：StarUML 开源与免费，轻量级的画图工具。 绘图软件：MAC版OmniGraffle和Win版visio OmniGraffle是一款相当全面的工具，用途很广泛,被誉为MAC上的visio。 抓包工具：Fiddler与Charles Fiddler是位于客户端和服务器端的HTTP代理，也是目前最常用的http抓包工具之一 。 它能够记录客户端和服务器之间的所有 HTTP请求，可以针对特定的HTTP请求，分析请求数据、设置断点、调试web应用、修改请求的数据，甚至可以修改服务器返回的数据，功能非常强大，是web调试的利器。 Charles通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。 git管理工具:sourcetree,smartGit SourceTree是强大的Git/Mercurial桌面客户端，支持Windows和Mac操作系统。但新版必须登录Atlassian账号，必须翻墙才能使用。通过SourceTree美观简单的界面，你可以放弃命令行了。总结出来就是：简约，美观。 虽然smartGit不如sourcetree界面那么美观，但smartGit并不需要翻墙，功能也能够满足我们的需求。 Win版桌面闹钟：梦畅闹钟 开发再有激情，也不能忘了保重自己的身体，大部分人coding时，喜欢沉迷代码无法自拔，容易忘记时间，这款软件恰好弥补这一点，但这款闹钟功能非常多，界面也非常美观。 保护视力：f.lux 和 护眼宝 在生理层面上，最容易受伤的首先就是我们的眼睛。尤其在夜间对着刺眼的屏幕，长久下来必会为眼睛健康埋下隐患，特别是电脑屏幕的蓝光更会对睡眠产生消极的影响，连苹果也都在 iPhone / iPad 上增加了夜间模式来过滤「蓝光」从而保护用户的眼睛。他们会根据当前时区，当前时间调整屏幕色温，达到保护眼睛的作用。 虚拟化容器：Docker 相信做开发的对于安装各种开发环境（tomcat,nginx,redis,mysql……）都比较烦，不仅如此，它还占用本机许多资源，导致本机笨拙，那么Docker的出现会解决我们的问题。 IDEA中超实用的插件 iedis 一个redis可视化插件 Mybatis Plugin帮助你轻松使用mybatis作为ORM的插件 GsonFormat 实体类和json互相转化的神器 插件名称 插件介绍 官网地址 GitOSC 开源中国的码云插件 https://plugins.jetbrains.com/plugin/8383-gitosc Alibaba Java Coding Guidelines 阿里巴巴出的代码规范检查插件 https://plugins.jetbrains.com/plugin/10046-alibaba-java-coding-guidelines IDE Features Trainer IntelliJ IDEA 官方出的学习辅助插件 https://plugins.jetbrains.com/plugin/8554?pr=idea Key promoter 快捷键提示 https://plugins.jetbrains.com/plugin/4455?pr=idea Grep Console 自定义设置控制台输出颜色 https://plugins.jetbrains.com/idea/plugin/7125-grep-console String Manipulation 驼峰式命名和下划线命名交替变化 https://plugins.jetbrains.com/plugin/2162?pr=idea MetricsReloaded 代码复杂度检查 https://plugins.jetbrains.com/plugin/93?pr=idea Statistic 代码统计 https://plugins.jetbrains.com/plugin/4509?pr=idea JRebel Plugin 热部署 https://plugins.jetbrains.com/plugin/?id=4441 CodeGlance 在编辑代码最右侧，显示一块代码小地图 https://plugins.jetbrains.com/plugin/7275?pr=idea GsonFormat 把 JSON 字符串直接实例化成类 https://plugins.jetbrains.com/plugin/7654?pr=idea Markdown Navigator 书写 Markdown 文章 https://plugins.jetbrains.com/plugin/7896?pr=idea Jindent-Source Code Formatter 自定义类、方法、doc、变量注释模板 http://plugins.jetbrains.com/plugin/2170?pr=idea Translation 翻译插件 https://github.com/YiiGuxing/TranslationPlugin Maven Helper Maven 辅助插件 https://plugins.jetbrains.com/plugin/7179-maven-helper Properties to YAML Converter 把 Properties 的配置格式改为 YAML 格式 https://plugins.jetbrains.com/plugin/8000-properties-to-yaml-converter Git Flow Integration Git Flow 的图形界面操作 https://plugins.jetbrains.com/plugin/7315-git-flow-integration Alfred 3 for Mac强大的粘贴 开源数据库客户端Sequel Pro 远程终端软件FinalShell","link":"/2017/06/06/高效工具集合/"}],"tags":[{"name":"服务器","slug":"服务器","link":"/tags/服务器/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"数据库","slug":"数据库","link":"/tags/数据库/"},{"name":"Kafka","slug":"Kafka","link":"/tags/Kafka/"},{"name":"集群","slug":"集群","link":"/tags/集群/"},{"name":"Redis","slug":"Redis","link":"/tags/Redis/"},{"name":"Shell","slug":"Shell","link":"/tags/Shell/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"SQL","slug":"SQL","link":"/tags/SQL/"},{"name":"solr","slug":"solr","link":"/tags/solr/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"Quartz","slug":"Quartz","link":"/tags/Quartz/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"zookeeper","slug":"zookeeper","link":"/tags/zookeeper/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"final","slug":"final","link":"/tags/final/"},{"name":"POI","slug":"POI","link":"/tags/POI/"},{"name":"Excel","slug":"Excel","link":"/tags/Excel/"},{"name":"SpringMVC","slug":"SpringMVC","link":"/tags/SpringMVC/"},{"name":"String","slug":"String","link":"/tags/String/"},{"name":"读书","slug":"读书","link":"/tags/读书/"},{"name":"笔记","slug":"笔记","link":"/tags/笔记/"},{"name":"函数式","slug":"函数式","link":"/tags/函数式/"}],"categories":[{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"位运算","slug":"位运算","link":"/categories/位运算/"},{"name":"Shell脚本编程","slug":"Shell脚本编程","link":"/categories/Shell脚本编程/"},{"name":"SQL","slug":"SQL","link":"/categories/SQL/"},{"name":"solr","slug":"solr","link":"/categories/solr/"},{"name":"Spring","slug":"Spring","link":"/categories/Spring/"},{"name":"git","slug":"git","link":"/categories/git/"},{"name":"Java内功第一重","slug":"Java内功第一重","link":"/categories/Java内功第一重/"},{"name":"工作实战","slug":"工作实战","link":"/categories/工作实战/"},{"name":"设计模式","slug":"设计模式","link":"/categories/设计模式/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"SpringMVC","slug":"SpringMVC","link":"/categories/SpringMVC/"},{"name":"读书笔记","slug":"读书笔记","link":"/categories/读书笔记/"},{"name":"Java8实战","slug":"Java8实战","link":"/categories/Java8实战/"},{"name":"工具","slug":"工具","link":"/categories/工具/"}]}